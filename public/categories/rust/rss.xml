<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>itscomputersciencetime</title>
        <link>https%3A//nsmryan.github.com/public/</link>
        <description></description>
        <generator>Zola</generator>
        <language>en</language>
        <atom:link href="https%3A//nsmryan.github.com/public/categories/rust/rss.xml" rel="self" type="application/rss+xml"/>
        <lastBuildDate>Sun, 16 Jun 2019 00:00:00 +0000</lastBuildDate>
        
            <item>
                <title>Rustic Flight Software Concept</title>
                <pubDate>Sun, 16 Jun 2019 00:00:00 +0000</pubDate>
                <link>https%3A//nsmryan.github.com/public/rustic-flight-software-concept/</link>
                <guid>https%3A//nsmryan.github.com/public/rustic-flight-software-concept/</guid>
                <description>&lt;p&gt;I have had a vision of a flight software system written in Rust that I wanted to write down.
The concept is a little rough, so this post is also a way to feel out the design and how it
fits into flight software design in general.&lt;&#x2F;p&gt;
&lt;p&gt;This is coming from a lot of thought into what makes a good flight software system, and from
working on and reading code from multiple systems, including CFS (a flight software system
developed by NASA). The result is something that combines ideas from several systems,
and from experience building and testing these systems, but with a re-imagining
in Rust.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;modules-vs-layers&quot;&gt;Modules vs Layers&lt;&#x2F;h1&gt;
&lt;p&gt;One of the main things I see in the architecture of flight software systems, and generally
in embedded systems, is that the system is a series of modules which communicate through
function calls or messages. Function calls give sychronious communication when necessary,
and messages (say, CCSDS packets) give asynchronous communication.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;types-of-modules&quot;&gt;Types of modules&lt;&#x2F;h2&gt;
&lt;p&gt;There are several types of modules in these systems, which I will attempt to enumerate:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Hardware abstraction modules- these can be drivers, generic libaries wrapping hardware,
or may have project-specific logic for talking to a particular piece of hardware over
a particular link&lt;&#x2F;li&gt;
&lt;li&gt;Infrastructure modules- these provide services to other modules. This can be things like
message routing, configuration, time, software&#x2F;event messages, logging, memory block allocation&#x2F;deallocation,
and can include many other things. These modules tend to be directly depended on, and in a sense they
fix the architecture in place- while other modules can be added and removed between projects, the
architectural modules are usually deeply embedded in the dependancies and logic of other modules.&lt;&#x2F;li&gt;
&lt;li&gt;Project modules- these are specific to a project, and are not intended to be portable or abstract.
They implement specific science objectives or project requirements. They may be tightly coupled
to each other to accomplish highly coordinated and precise tasks.&lt;&#x2F;li&gt;
&lt;li&gt;Library modules- these provide algorithms or interfaces, but have no tasks. They are often, but
not always, very portable and testable.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;cfe-cfs-approach&quot;&gt;CFE&#x2F;CFS Approach&lt;&#x2F;h2&gt;
&lt;p&gt;CFS factors the abstraction into the OSAL (Operating System Abstraction Layer) and PSP (Platform Support
Package) code, and builds the rest of the system on top of these. The next layer up is the CFE (Core
Flight Executive) which factors all of the infrastructure modules into a single tightly coupled group,
essentially removing coupling from the rest of the system. This feels like a kind of quotient group,
if you have some abstract algebra.&lt;&#x2F;p&gt;
&lt;p&gt;The nice thing about this is that while all modules rely on dependance to CFE, many things that are otherwise
services become independant by working through CFE&#x27;s services- task schedule is done through the software bus,
and so is telemetry monitoring, health and status generation, and many other features.&lt;&#x2F;p&gt;
&lt;p&gt;This is not a bad architecture, but I think there is value in modularity over laying, and I think there are alternative
architectures which have some very nice properties along those lines.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;purely-modular-approach&quot;&gt;Purely Modular Approach&lt;&#x2F;h2&gt;
&lt;p&gt;In a purely modular approach to this problem, each module would expose an API that other modules could depend on.
Rather then layering the system, each module could receive an implementation of each interface it uses, perhaps
at runtime in a dependancy injection style. This lack of laying creates a web of modules rather then a heirarchy,
which should assist in swapping out modules and implementations.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;potential-advantages&quot;&gt;Potential Advantages&lt;&#x2F;h3&gt;
&lt;p&gt;The advantage to this is that modules would be exchangable even in the core infrastructure, and no module would be
treated specially. The other advantage would be testing- each module could provide a kind of mock implementation
as well as a real one, and each module that uses an interface could test without the other module&#x27;s code running by
using this mocked implemnatation.&lt;&#x2F;p&gt;
&lt;p&gt;Modularity here is not a purely acedemic goal. For example, CFS has a single monolithic abstraction layer, which helps
make the task of porting straightforward (it is clear what you need to implement to create a new implementation), but
it means that it is very hard to extend without modifying all other implementations. It also means you take around
all components provided, even though I know many systems which do not use them all.&lt;&#x2F;p&gt;
&lt;p&gt;The other advantage I could see is potentially huge- composability of modules. This would either take the form
of interfaces implemented in terms of other interfaces, or interfaces composed together to provide the final
implmementation. One place where this could be helpful is to create an implementation that logged function
calls in some way before passing the data around- none of the flight software would have to change, but you
could get instrumentation that visualized or at least recorded interactions between components with very
little effort. An example of composing interfaces might just be that a configuration manager interface might
be implemented in terms of a file system interface, or an interface that both forwards data to the intended
target and records it to a log file for later downlink.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;loose-coupling-and-types&quot;&gt;Loose Coupling and Types&lt;&#x2F;h3&gt;
&lt;p&gt;Interestingly, it seems that this kind of design involve systems that talk, but are developed without knowledge of
each other types. Configuration management won&#x27;t know about the configuration structures it provides, a software
bus would not nescessarily know about the message types it routes, etc. Currently this is often done in C through pointer
casting. I&#x27;m not sure what this would look like in Rust- either through generics, type ids or Any types, or perhaps
some unsafe code if all else fails.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;rustic-flight-software&quot;&gt;Rustic Flight Software&lt;&#x2F;h1&gt;
&lt;p&gt;Here is the idea- each module takes a series of interfaces at startup and uses them for all outside communication.
This acts as a kind of software abstraction layer- I imagine hardware could be abstracted in a HAL (Hardware Abstraction
Layer) approach as is currently being used in the Rust ecosystem, so I&#x27;m talking only about software abstraction here.&lt;&#x2F;p&gt;
&lt;p&gt;The software abstraction might take the form of types implementing a particular interface, or could perhaps
be a Trait object.  Either way, it would contain a way to register and discover services provided elsewhere in
the system.&lt;&#x2F;p&gt;
&lt;p&gt;To support this concept, I think the system would use a registry of interfaces, where each module provides a way to
supply implementations of one or more interfaces, and modules can request an implementation of one or more interfaces.
I would imagine that the system requires that all modules get each interface they require, and that no interface is
provided more then once.&lt;&#x2F;p&gt;
&lt;p&gt;For hardware there is an advantage to multiple implementations of the same interface in
case the system has multiple components that use the same hardware abstraction but are different under the hood,
but for software I feel that having multiple implementations is too likely to be a source of bugs and should be avoided
in flight software.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;interface-registry&quot;&gt;Interface Registry&lt;&#x2F;h2&gt;
&lt;p&gt;My current thinking is that the interface registry is a map from type ids to Trait objects. Each module might expose
a function that takes a mutable reference to this registry and inserts its own implementation of its interfaces.
If an implementation already exists, this is an error at startup.&lt;&#x2F;p&gt;
&lt;p&gt;Then each module provides a function that takes an immutable reference to this registry and pull out a reference
to each interface it needs to use. A module might request access to the software message interface to report
its progress and errors, the configuration interface to get access to its configuration table, the software bus
interface to send and receive packets, and the time interface to generate timestamps in the system&#x27;s time reference.&lt;&#x2F;p&gt;
&lt;p&gt;One nice thing that comes out of this registery is that a system needs to only implement interfaces it uses-
the selection of modules for a new system is very fine grain and matches only what the system needs without
taking in a group of required modules. Ideally the dependacy information between modules would be easily
discoverable or reportable in this system, as they would form a web of dependancy which the user would have to
be aware of.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;startup&quot;&gt;Startup&lt;&#x2F;h3&gt;
&lt;p&gt;Ideally each module could be statically linked, creating a single executable from the whole system, or could be loaded
as a shared object.&lt;&#x2F;p&gt;
&lt;p&gt;If loaded as a shared object, the module&#x27;s functions to provide interfaces and request interface could
be called- all module&#x27;s functions to provide interfaces would be called first, and then all module&#x27;s functions to request
interface, and then finally perhaps a function to initialize the modules.&lt;&#x2F;p&gt;
&lt;p&gt;If loaded as a static object, the modules might just be provided their implementations directly.
I imagine that in a flight software system this registry might also be filled out manually in a top level function
so there is no ambiguity about what it contains- sometimes flexibility is more dangerous then its worth.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;testing&quot;&gt;Testing&lt;&#x2F;h1&gt;
&lt;p&gt;One of the advantages to this system is testability. Each module is self contained- it requires linking against
an interface definition, but not an implementation, so it can be mocked out and tested independantly.&lt;&#x2F;p&gt;
&lt;p&gt;This would allow testing that is currently very difficult. In CFS there is an extensive testing system which
does someting similar, but I think the design in this post allows a much lower effort way to do this kind
of module testing.&lt;&#x2F;p&gt;
&lt;p&gt;Ideally each module could be tested on the development system, with as much unit testing as possible. The
tests could also be run on the target system, followed by system level tests of the combined system.&lt;&#x2F;p&gt;
&lt;p&gt;One thing that would be a huge gain that I haven&#x27;t seen done is that a group of modules could be started,
each depending on each other, but with some modules mocked out, and then the group could be tested together.
This could lead a huge amount of flexibility in testing where whole sections of the system could be started and
stopped for a single test of their interfaces.&lt;&#x2F;p&gt;
&lt;p&gt;I find that it is commonly true that interfaces betweeen components are a source of bugs, so this kind of
isolated interface testing could be a huge gain for a Rustic Flight Software.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;implementation&quot;&gt;Implementation&lt;&#x2F;h1&gt;
&lt;p&gt;I&#x27;ve done some experiements implementing this kind of archtitecture in C, and I found that while it is possible,
it is certainly not what I&#x27;m used to doing in flight software. There is a certain amount of indirection- in my
implementation abstracted function calls take a pointer to a struct containing function pointers (basically
a Trait object). &lt;&#x2F;p&gt;
&lt;p&gt;This does work, but I haven&#x27;t been able to think of a path in which this effort goes anywhere- I would have to
re-invent an entire flight software system for this to work. While it would be cool to do this, and maybe run
it on some hobby electronics system, if I&#x27;m going to put this concept into practice
I would rather do it in Rust and see if a Rustic Flight Software system is doable.&lt;&#x2F;p&gt;
&lt;p&gt;I currently have no plans to start serious work on this concept- I hope to play around with it and see where it goes,
perhaps building tiny systems to see where it works and where it doesn&#x27;t. However, I have so many other
projects with more immediate gains to be had, while this one is more an idle concept for now. That is one
of the reasons I wanted to write this post and get the idea down while it incubates in my subconcious.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;prototype&quot;&gt;Prototype&lt;&#x2F;h2&gt;
&lt;p&gt;A minimum prototype of this concept might have the following pieces:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;A crate implementating the interface registry concept.&lt;&#x2F;li&gt;
&lt;li&gt;A group of crates with interface traits and types, as well as the testing implementation
of the interface.&lt;&#x2F;li&gt;
&lt;li&gt;A group of crates with implementations of those interfaces. This would be limited to some
basic interface for the prototype.&lt;&#x2F;li&gt;
&lt;li&gt;A crate that combines these pieces into a single project, depending on interface and implementation
crates, and loading (dynamically or statically) a system made out of these parts.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;The components I would probably start with would be a software message&#x2F;event message component (because
it should be simple), a software bus (because it is a fairly central service), and perhaps a time
interface (because it is different from the other two). &lt;&#x2F;p&gt;
&lt;p&gt;The final system would ideally run in Window and Linux, and do some kind of communication between components.
If it was integrated with COSMOS and could be commanded and provided telemetry it would go a long way
to feeling like a legitimate system.&lt;&#x2F;p&gt;
&lt;p&gt;The goals for the prototype would be to see the loose coupling of the module system in work, see how Rust&#x27;s
type system helps or impedes modularity in this design, and get some evidence to suggest how Rust fits
into this kind of software. I would be interested in things like command&#x2F;telemetry generation, inspection
of types, re-use between ground and flight software, testing, safety in memory use and concurrency,
and what difference show up when flight software concepts are implemented in Rust.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h1&gt;
&lt;p&gt;Hopefully this post presents a useful flight software system design and the start of how a Rust flight software
system might have advantages over what is currently available.&lt;&#x2F;p&gt;
&lt;p&gt;I would very much like to make progress on this, and I will try to keep this blog updated with new posts
if I do.&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>Just Rust</title>
                <pubDate>Sat, 23 Feb 2019 00:00:00 +0000</pubDate>
                <link>https%3A//nsmryan.github.com/public/just-rust/</link>
                <guid>https%3A//nsmryan.github.com/public/just-rust/</guid>
                <description>&lt;p&gt;I wanted to mention an awesome tool call &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;casey&#x2F;just&quot;&gt;just&lt;&#x2F;a&gt; written in Rust.
I&#x27;ve started using it in my everyday toolchain, and its been very pleasant and useful, so I wanted
to mention it here.&lt;&#x2F;p&gt;
&lt;p&gt;The tool is very simple- you make a file called justfile or Justfile and add rules that, when run, perform
some action you want to take. This replaces the series of shell scripts, or the makefile, that might
develop with a project which runs common commands like building, testing, or performing a frequent
action.&lt;&#x2F;p&gt;
&lt;p&gt;At first I was somewhat skeptical- I was already using make for this kind of thing, and it was
working well enough without adding a new tool in the mix. However, when I gave &#x27;just&#x27; a try,
it made keeping these commands around much simpler and easier. The tool does only one thing,
unlike make, and it is specialized for its use case.&lt;&#x2F;p&gt;
&lt;p&gt;Its very easy to add a command, to list commands, and to run them. There are a couple extra features
like command arguments, but nothing like the huge documents describing how to use make.&lt;&#x2F;p&gt;
&lt;p&gt;I expect to continue to use this tool as a simpler way to manage my project-specific commands, and if
you have any interest in simplifying your workflow, give it a try.&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title> Rust In Space- Integrating CFS And Rust</title>
                <pubDate>Sun, 16 Dec 2018 00:00:00 +0000</pubDate>
                <link>https%3A//nsmryan.github.com/public/rust-in-space-cfs-and-rust/</link>
                <guid>https%3A//nsmryan.github.com/public/rust-in-space-cfs-and-rust/</guid>
                <description>&lt;p&gt;This post is about the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;nsmryan&#x2F;cfs-sys&quot;&gt;cfs-sys&lt;&#x2F;a&gt; Rust crate which generates the
bindings required to write CFS Apps in Rust. This include all public include files from CFE,
OSAL, and the PSP.&lt;&#x2F;p&gt;
&lt;p&gt;The idea is that this is a step in the direction
of getting Rust into space by allowing it to interoperate with NASA&#x27;s open source flight software
architecture CFS. Its not likely that this will be the first way Rust gets into space (see
the work that Kubos is doing), but the
more Rust in space the better in my opinion. If you are already using CFS, and want to integrate some
Rust into your codebase, this crate can help you make that happen.&lt;&#x2F;p&gt;
&lt;p&gt;A very brief description of CFS- CFS is a combination of projects (OSAL, CFE,
CFS) which provide a core set of functionality commonly seen in space and drone system. It was 
developed and released by NASA and is used by many projects across many NASA centers.
The functionality it provides includes
configuration tables, time management, module communication, logging, event messages, memory
pools, and much more. This is all on top of an abstraction layer to assist with portability across
operating systems (OSAL) and across different boards (PSP).
In addition, there is a way to add new modules, and a library of existing modules that can be plugged in
called Apps. The existing apps provide task scheduling, stored commands, data storage, file
transfer, limit monitoring, housekeeping, and a number of other capabilities.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;cfs-sys&quot;&gt;cfs-sys&lt;&#x2F;h1&gt;
&lt;p&gt;The cfs-sys crate is intended to be used in a situation where you have a build of CFS that you are
using, and you want to write an App in Rust. This App will integrate with the rest of the CFS system
just like any other App- I didn&#x27;t have to make any changes to the rest of CFS to get this working.&lt;&#x2F;p&gt;
&lt;p&gt;The bindings are generated using BindGen in the build.rs file. This turned out to be fairly straightforward-
I just used the environmental variables provided by CFS to point bindgen to the right files. BindGen is
amazingly easy to use, so this was not nearly as painful as I expected.&lt;&#x2F;p&gt;
&lt;p&gt;There is an &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;nsmryan&#x2F;cfs_app_rs&quot;&gt;example App&lt;&#x2F;a&gt;,
which is in the apps&#x2F;rust&#x2F; directory in that project, which builds an .so which can be loaded by
CFS. This module is loaded by adding it to the build&#x2F;cpu1&#x2F;cfe_es_startup.scr
script which is used by CFS to determine which modules to load at runtime.&lt;&#x2F;p&gt;
&lt;p&gt;Luckily the CFS build system does not build Apps directly- it just calls make files in each App&#x27;s
directory. This way we can build a Rust project and just make sure that the resulting files end up in
the right place, with the rest of CFS none the wiser about how the module was built.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;building&quot;&gt;Building&lt;&#x2F;h1&gt;
&lt;p&gt;The cfs-sys crate it integrates into the CFS build through environment
variables defined in the setvars.sh script that you run before building CFS. The cfs_app_rs repo 
shows how to integrate your Rust app by adding it to the build&#x2F;cpu1&#x2F;Makefile just like any other app,
and then using the apps&#x2F;rust&#x2F;fsw&#x2F;for_build&#x2F;Makefile to set up your Rust App and build it using cargo.&lt;&#x2F;p&gt;
&lt;p&gt;The bindings are generated with BindGen and appear to work as expected. I have not wrapped them in a Rustic
interface, so they are used raw with all the *mut that this implies.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;usage&quot;&gt;Usage&lt;&#x2F;h1&gt;
&lt;p&gt;The cfs-sys crate is on crates.io, so you can depend on it in Cargo.toml with:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212733;&quot;&gt;
&lt;span style=&quot;color:#ccc9c2;&quot;&gt;cfs-sys=&amp;quot;0.1&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Adding cfs-sys to a Rust file is as easy as:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212733;&quot;&gt;
&lt;span style=&quot;color:#ffa759;&quot;&gt;extern crate&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ccc9c2;&quot;&gt; cfs_sys&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ccc9c2cc;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffa759;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ccc9c2;&quot;&gt;cfs_sys&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f29e74;&quot;&gt;::*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ccc9c2cc;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;I haven&#x27;t split out the bindings into separate modules to allow more fine grain control, opting for simplicity
for now. &lt;&#x2F;p&gt;
&lt;p&gt;Once the bindings are imported, you proceed like any other CFS App- call CFE_ES_RegisterApp, call CFE_ES_GetAppID to
get your APID, register events with CFE_EVS_Register, set up messages with CFE_SB_InitMsg&#x2F;CFE_SB_CreatePipe&#x2F;CFE_SB_Subscribe.
Then just wait for CFE_ES_WaitForStartupSync, and loop blocking for CFE_SB_RcvMsg. You can check for system shutdown with CFE_ES_RunLoop,
and mark sections of you code with CFE_ES_PerfLogEnter and CFE_ES_PerfLogExit as normal, although I did have to wrap the perf log
functions up as they are macros in CFS and don&#x27;t seem to get turned into Rust functions.&lt;&#x2F;p&gt;
&lt;p&gt;The example app shows how you can do this and get your App talking to CFS. It could use some work, but it runs
and proves that Rust is useable with CFS. It is even configured in the SCH App to receive its wakeup message every second, although
the message is build with hardcoded values rather then putting those in headers and then generating Rust bindings for them.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;limitations&quot;&gt;Limitations&lt;&#x2F;h1&gt;
&lt;p&gt;The cfs-sys bindings are only for OSAL&#x2F;CFE&#x2F;PSP includes- if you need to bind against a particular CFS App&#x27;s headers, that would either have to be
done separately or the cfs-sys would need flags to build bindings for a particular set of Apps. I could easily see a set of crates like
cfe-hk-sys, cfe-sch-sys, etc which provide bindings to each App.&lt;&#x2F;p&gt;
&lt;p&gt;I have not wrapped the bindings in a Rustic interface (hence the -sys in the name), which makes them awkward to use. Nearly all code
must be unsafe in a Rust App right now. In addition, macros in CFS do not result in bindings in cfs-sys for some reason. I thought 
generate_inline_functions was supposed to do this, but I haven&#x27;t been able to get it to work.&lt;&#x2F;p&gt;
&lt;p&gt;The integration of the build process for a Rust App and the rest of CFS does work, but does not include unit testing or documentation generation.
I also haven&#x27;t looked at how the CFS cmake system might integrate with Rust as I do not currently use it.&lt;&#x2F;p&gt;
&lt;p&gt;The build currently forces the target for cargo to be &#x27;i686-unknown-linux-gnu&#x27;, which could be made configurable. I don&#x27;t have a good
test system to work on generalizing this, but it shouldn&#x27;t be hard.&lt;&#x2F;p&gt;
&lt;p&gt;I also hardcoded the choice &lt;em&gt;LINUX_OS&lt;&#x2F;em&gt; required for network_includes.h in CFE. This is in the build.rs for cfe-sys.&lt;&#x2F;p&gt;
&lt;p&gt;A CFS App is expected to have a series of header files for message IDs, configuration parameters, etc. These are usually internal,
but certain tools expect them to be there, and if you have to, say, add a message to the SCH App&#x27;s schedule for a particular App,
you need to include these files. A Rust App should really create these files like a C App would, and then generate bindings for
Rust. This way the App fits into the ecosystem without requiring special cases for Rust Apps. The example App does not do this,
so when it is integrated with SCH, I&#x27;m using a hardcoded number instead of including a header file.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;future-work&quot;&gt;Future Work&lt;&#x2F;h1&gt;
&lt;p&gt;From the list of limitations, it should be clear that this is a prototype and a work in progress.&lt;&#x2F;p&gt;
&lt;p&gt;While I am using CFS for software that will one day make its way to space, I may or may not be able to integrate Rust into that codebase.
This means that this project will continue to be a proof of concept unless someone can help make it more professional and better integrated
into CFS, ideally by using it in practice.&lt;&#x2F;p&gt;
&lt;p&gt;I would like to keep working on it, especially the example App since it is an important starting point for people. If I do end up
using Rust at work, I will certainly post about it, so stay tuned if this interests you. I expect the fires of production use would
forge this project into a full solution for Rust&#x2F;CFS integration.&lt;&#x2F;p&gt;
&lt;p&gt;Otherwise, I hope this is interesting for someone, and Rust on!&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>Why I Like Rust</title>
                <pubDate>Sat, 29 Sep 2018 00:00:00 +0000</pubDate>
                <link>https%3A//nsmryan.github.com/public/why-i-like-rust/</link>
                <guid>https%3A//nsmryan.github.com/public/why-i-like-rust/</guid>
                <description>&lt;p&gt;I&#x27;ve been very much into Rust recently. I try to write some Rust every day, and I&#x27;ve
released two crates to crates.io (an implementation of the CCSDS Primary Header, and 
Rustic bindings to the C library jsmn).&lt;&#x2F;p&gt;
&lt;p&gt;When asked why I like Rust, I have only been able to give partial answers. I hope this
post can give a more complete answer. The take-aways are that Rust fulfills a set of
required criteria for use in my work, it provides nice things built in to the language
and ecosystem, ways of thinkings that
make software development fun, and it provides a set of tradeoffs that fit the needs
that I personally have in the programs that I write.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;criteria&quot;&gt;Criteria&lt;&#x2F;h2&gt;
&lt;p&gt;In aerospace software work, there are some fairly strict criteria on what languages are
even potential candidates for us to use. Rust manages to fulfill the criteria that I personally
have, which is so rare that the only other languages I can think of that do this are C, C++,
and perhaps Ada (although I&#x27;ve never used Ada). I&#x27;m not saying there are no other options, just
none that I&#x27;m familiar with.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;no-garbage-collection&quot;&gt;No Garbage Collection&lt;&#x2F;h3&gt;
&lt;p&gt;One example is that a garbage collected language is
a complete non-starter for us- the complexity and lack of control over latency is a real issue. As
I&#x27;ve noted in other posts, we don&#x27;t release memory, much less allow it to be collected- you
ask for as much as you need and you stay within those bounds. We also are usually more
concerned about latency then about throughput- we often have fast enough processors to do the
work, but we need to get certain things done in tight time constraints.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;memory-layout&quot;&gt;Memory Layout&lt;&#x2F;h3&gt;
&lt;p&gt;Another criteria is control over memory layout- we often deal with packets and other structures
where every bit and every byte must be placed correctly in memory. C provides this control, although
for bit layout it is either messy or non-portable, but you can do it. If a language does not
provide this control, or requires marshalling and unmarshalling into its internal structures, it is
not a non-starter, but its a big impediance mismatch that effects a great deal of code.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;maturity&quot;&gt;Maturity&lt;&#x2F;h3&gt;
&lt;p&gt;Immature languages can be a non-starter. Rust fall into this to a certain extent, but the
difference is that it looks like it is going to be around for a long time, while many other
languages that have promised to be safer systems language seem to have faded out or never
made it beyond the original group developing them. &lt;&#x2F;p&gt;
&lt;h3 id=&quot;integration-with-c-c&quot;&gt;Integration with C&#x2F;C++&lt;&#x2F;h3&gt;
&lt;p&gt;Integration with C, and ideally C++, is a must-have. There is just too much code written
in C&#x2F;C++ out there that we depend on to ignore this. Rust&#x27;s FFI is the best that I&#x27;ve personally used,
and I&#x27;ve found that bindgen allows very easy binding generation. I would imagine that Rust could
get into aerospace in small pieces, replacing a module here and there, and interoperation with C&#x2F;C++
is what would allow that to happen.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;simplicity&quot;&gt;Simplicity&lt;&#x2F;h3&gt;
&lt;p&gt;Ideally, any language we used would be very simple- the more concepts that you introduce into your
programs the more interactions between those concepts are possible, and the more ways you can make
mistakes. With C++ we deal with that the way I think everyone does- we use a certain subset of the
language. I could see something like this with Rust- restrict how we use abstraction, probably
forbid macros, perhaps limit use of Traits, things like that. This would have to be developed out
of experience developing high-assurance Rust, which I certainly don&#x27;t have.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;safety-and-restrictions&quot;&gt;Safety and Restrictions&lt;&#x2F;h3&gt;
&lt;p&gt;The last criteria that I can see would be restrictions- I want a language that is more restrictive in
what it allows me to do. There are a lot of ways to make mistakes in programming, and I am more concerned about
preventing mistakes then about moving quickly. I want as large a class of mistakes as possible to be caught
automatically and every time I compile so I can focus on the more complex issues and system level problems rather
then the low level memory use problems.
In this area, I may actually want Rust to be more restrictive then it is, but I don&#x27;t have enough experience to say.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;rust&quot;&gt;Rust&lt;&#x2F;h2&gt;
&lt;p&gt;Not only does Rust seem to deliver on all of my requirements, it just feel productive, and it provides so many nice things that make software
development a better experience. I was used to an integrated build tool and easy dependancies from Haskell, and 
a mess of different tools and difficult dependancies from C&#x2F;C++. With Rust, cargo has been easier for me to learn
and less error prone then stack (in my own experience), and I have had remarkably few issues with building and
dependancies. &lt;&#x2F;p&gt;
&lt;p&gt;Rust feels to me like a mixture of Haskell and C, with good parts of both and very few compromises on each.
I like thinking and modeling problems in terms of algebraic data types, and I like knowing how my memory is
arranged, and knowing when my code is doing what. As much as I like Haskell, it was hard for me to give up
that kind of control, even though I understand the composability advantages of lazyness and the advantages of
immutability, I wanted more control, and perhaps I also just wanted more of what I was used to in other languages.&lt;&#x2F;p&gt;
&lt;p&gt;In C I feel like I can never go beyond a certain level of abstraction- the language is just too primitive
to think very abstract thoughts. Very often I don&#x27;t want abstraction, but when I do it is not available.
On the other hand, Haskell is very abstract and we can think thoughts that I would find almost unimaginable
in C. Rust is a middle ground- there is enough abstraction that I haven&#x27;t felt confined, but not so much
that I don&#x27;t have control over what is happening. This did cause me some trouble in Haskell, where the barrier
between Haskell and system was always hard for me to cross and feel like I understand exactly what was happening.&lt;&#x2F;p&gt;
&lt;p&gt;I like the fact that data is immutable by default in Rust, and I am so very, very glad that Rust uses a 
type-class-like mechanism instead of being Object Oriented. I don&#x27;t think I would have ever started writing
Rust if it supported, or even just encouraged, object oriented programming. The Trait system has worked out
well for me so far, although the syntax can be a bit complex when handling type variables. However, I am willing
to put up with small things like that for a safer system&#x27;s language. The automatic deriving mechanism is similar
to Haskell, where you tie your data types into the language and ecosystem in a very lightweight way. I haven&#x27;t
tried to do my own automatic deriving, but at least it is possible.&lt;&#x2F;p&gt;
&lt;p&gt;There is not as much advanced type theory as Haskell, but since I don&#x27;t program in Haskell enough to effectively
use much of its abstractions, they were always more of a distraction. In Rust, I just do what works using tools
that are more familiar, and it doesn&#x27;t both me if there is duplication or things aren&#x27;t perfect the way it would
in Haskell. This is mostly my own fault, but Haskell programming never felt as productive as I feel in Rust.&lt;&#x2F;p&gt;
&lt;p&gt;Speaking of productivity, I like that Rust is fast. I write a lot of C, and I kind of expect performance, so its
nice to know that I can generally expect high performance on normal tasks in Rust. I know that for many tasks,
performance isn&#x27;t really that critical, but its nice to know you can get it when you need it, and its just nicer
when things are fast.&lt;&#x2F;p&gt;
&lt;p&gt;The memory safety of Rust is another huge advantage for me. Its not exactly that we have a lot of memory corruption
issues at work, but when they do happen they are hard to track down, and can cause very bad things to happen. I
don&#x27;t like knowing that there could be hidden issues buried somewhere in our code base that could cause a crash
some time in the future- there is just no way to be completely sure we did everything right everywhere even with
static analysis, reviews, and multiple levels of testing. If we could use a more restricted language, even if only
for certain modules, it would reduce the error surface of the code and give me more confidence in its correctness, which
is a big deal. Its especially a big deal because it is not a separate tool, or a proof in a formal methods system, it is
built in and run every time you compile- its likely not as complete as a more expensive formal methods approach, say, but
it is fast and automatic.&lt;&#x2F;p&gt;
&lt;p&gt;Rust also just has nice features, like integrated tests in code modules that reduce the barrier to testing. I can
just put in a couple quick sanity checks and run them at a moments notice, or every time I save, with no
extra infrastructure or work on my part. I haven&#x27;t used the built in benchmarked, but I hope it is as easy
as testing. That is not to say that I&#x27;m doing testing the best way in Rust, but the lower barrier to entry
just makes it so easy to get started.&lt;&#x2F;p&gt;
&lt;p&gt;One features that makes a big difference to me is error handling. The Option&#x2F;Maybe type and Result&#x2F;Either type
are not new to me, but being able to use them in embedded code is a big deal. My C code spends much more time
checking for errors then actually doing work, and propagating errors within a code base takes a great deal of
effort. I&#x27;ve seen places where C&#x27;s error handling leads to very inconsistent mechanisms even within related code,
and it is a lot of work to try to ensure all errors are checked, handled correctly, and propagated throughout the
code correctly. I like the idea of the &#x27;?&#x27; operator, and I could imagine it replacing my current strategy of
surrounding all code blocks in a check for whether any errors have occurred.  In VxWorks this looks like&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212733;&quot;&gt;
&lt;span style=&quot;color:#ccc9c2;&quot;&gt;STATUS result &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f29e74;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ccc9c2;&quot;&gt; OK&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ccc9c2cc;&quot;&gt;;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ccc9c2;&quot;&gt;

result &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f29e74;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffd580;&quot;&gt;XX_SomeFunction&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ccc9c2;&quot;&gt;()&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ccc9c2cc;&quot;&gt;;

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffa759;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ccc9c2;&quot;&gt;(result &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f29e74;&quot;&gt;==&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ccc9c2;&quot;&gt; OK)
{
  result &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f29e74;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffd580;&quot;&gt;XX_NextFunction&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ccc9c2;&quot;&gt;()&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ccc9c2cc;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ccc9c2;&quot;&gt;}

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffa759;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ccc9c2;&quot;&gt;(result &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f29e74;&quot;&gt;==&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ccc9c2;&quot;&gt; OK)
{
  result &lt;&#x2F;span&gt;&lt;span style=&quot;color:#f29e74;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffd580;&quot;&gt;XX_AnotherFunction&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ccc9c2;&quot;&gt;()&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ccc9c2cc;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ccc9c2;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;which would become&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212733;&quot;&gt;
&lt;span style=&quot;color:#ccc9c2;&quot;&gt;XX_SomeFunction()&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f29e74;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ccc9c2cc;&quot;&gt;;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ccc9c2;&quot;&gt;
XX_NextFunction()&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f29e74;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ccc9c2cc;&quot;&gt;;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ccc9c2;&quot;&gt;
XX_AnotherFunction()&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f29e74;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ccc9c2cc;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;I&#x27;ve also just found that when I wanted something, Rust has had an answer that fits well in my use-case. When I wanted
to generate bindings to a C library, there was bindgen, when I wanted control over my memory layout, there was repr(C),
when I wanted to allow a choice of compile directives when compiling jsmn in the jsmn-rs crate, there was features,
when I wanted to decode binary data, there was bytes. One of the first things I did with Rust was try to cross compile
it for an ARM board I had, just to see if it would work, and I was amazed by how much easier rustup is to use compared
to cross compiling in C. &lt;&#x2F;p&gt;
&lt;h2 id=&quot;some-negatives-to-balance-out-the-post&quot;&gt;Some Negatives, to Balance out the Post&lt;&#x2F;h2&gt;
&lt;p&gt;Of course, there are some areas of Rust that are not ideal. I&#x27;m will to accept a lot of issues to get all the nice
things Rust provides, and I don&#x27;t expect perfection, so these are not deal-breakers, but they are there.&lt;&#x2F;p&gt;
&lt;p&gt;One is that I find the use of macros in Rust a little concerning. I don&#x27;t like looking at a library, and realizing that
it is some kind of DSL, the rules of which I have to determine from examples or documentation. They can be very easy to use at
times, but as soon as you want to go off the beaten path, or you need to know exactly how they work, there is a lot of work
involved in decoding them. This is partially my lack of familiarity with Rust macros, but it just makes me wonder what is lacking
in the language that the best way to express something is a DSL. I&#x27;m a fan of DSLs in general, but it just feels wrong to me
to use them for basic tasks. This is something I need to think more deeply about to understand the core reason they are used
so much in Rust.&lt;&#x2F;p&gt;
&lt;p&gt;Another issue is language immaturity- it would be a hard sell to try to get a newer language used on a large project at work.
Maybe on a smaller project I could get it in, but there is a lot of trust in experience in aerospace.&lt;&#x2F;p&gt;
&lt;p&gt;The Trait system, while I like it in many ways, can lead to situations where it is hard to figure out how to accomplish a particular
task. There is enough abstraction that the available functions you can call on a type can be a hunt around documenation. Its not
been too bad for me, and I&#x27;m used to this from Haskell, but at times I rely on documentation to provide examples, and have trouble
figuring out how to accomplish something due to the amount of type resolution one needs to do in one&#x27;s head. Again, this hasn&#x27;t
been a big problem, but the complexity is there, and its very visible in the docs section on Traits for certain types.&lt;&#x2F;p&gt;
&lt;p&gt;One aspect of Rust development I have had a problem with occasionally is compile times. They aren&#x27;t as bad as I had in Haskell,
but they don&#x27;t seem nearly as fast as C. Luckily we have &#x27;cargo check&#x27;, which helps a great deal, and I think the compile time
issue has seen a lot of work and is being taken seriously, but its worth mentioning.&lt;&#x2F;p&gt;
&lt;p&gt;When trying out Rust integration with CFS, I have found that the large object files it produces are a problem. If I needed to
uplink a 3 MB binary file just to update a single module, then it is a problem. I know that there are ways to reduce object
file size, but so far my attempts still result in orders of magnitude larger files then I get from C.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;So far I&#x27;m very happy with what I&#x27;ve found in Rust. I feel productive, and I feel like low level programming isn&#x27;t so much work
and pain. I feel like I have the level of control that I want, along with enough abstraction to go beyond the confines of C.&lt;&#x2F;p&gt;
&lt;p&gt;Thats all I can think of for now. Rust on.&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>Rust CCSDS Primary Header Crate</title>
                <pubDate>Tue, 04 Sep 2018 00:00:00 +0000</pubDate>
                <link>https%3A//nsmryan.github.com/public/rust-ccsds-primary-header-crate/</link>
                <guid>https%3A//nsmryan.github.com/public/rust-ccsds-primary-header-crate/</guid>
                <description>&lt;p&gt;I published my first crate! Its called ccsds_primary_header and it contains an 
implementation of the CCSDS header defined in the Space Packet Protocol document.&lt;&#x2F;p&gt;
&lt;p&gt;This header is used in a lot of space systems, including the Interational Space
Station, satellites, and many (but not all) cubesat applications. Its very simple,
but has a lot of extensions that are not standardized and depend on the application.
The ISS has a whole series of secondary headers used for different packets, and the
CCSDS standards themselves have a whole document on the format of time fields in
secondary headers.&lt;&#x2F;p&gt;
&lt;p&gt;I only implemented the very basics, with the idea that it could be extended with
extra information for specific projects. This post is about what I ended up with,
and what the experience was like.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;finishing-up-the-crate&quot;&gt;Finishing Up The Crate&lt;&#x2F;h1&gt;
&lt;p&gt;I talked in a previous post about writes and re-writes that I ended up attempting
while writing this crate. I tried the bitfields crate, and found that I didn&#x27;t
know how to enforce a bigendian format on the packets, so I ended up just
implementing functions for getters and setters for each field in the packet using
byteorder.&lt;&#x2F;p&gt;
&lt;p&gt;This interface is somewhat awkward because you have to type something like&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212733;&quot;&gt;
&lt;span style=&quot;color:#ccc9c2;&quot;&gt;pri_header&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f29e74;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ccc9c2;&quot;&gt;control&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f29e74;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#f28779;&quot;&gt;apid&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ccc9c2;&quot;&gt;()
&lt;&#x2F;span&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;To get the APID of a packet- you need to drill down to the word where your data
is contained and then get the field as a function.&lt;&#x2F;p&gt;
&lt;p&gt;I decided to not implement the functions at the PrimaryHeader struct level, despite
the extra typing, because I think they make more sense where they are.&lt;&#x2F;p&gt;
&lt;p&gt;My favorite thing about the representation I ended up with is that the PrimaryHeader
struct is laid out in memory according to the standard-- there is no serialize or
deserialize step. This is more like how one would likely do this in C, and I like
this for manipulating packets without a lot of ceremony.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;similar-crates&quot;&gt;Similar Crates&lt;&#x2F;h1&gt;
&lt;p&gt;To my surprise, I stumbled on &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Stefan-Korner&#x2F;space_rust_library&quot;&gt;this repo&lt;&#x2F;a&gt;
while publishing my crate. It seems to be another implementation of CCSDS, along with
some secondary header functions for checksums and time. It uses more abstraction,
with its own bit field macros. Interesting to see this- some one else seems to be
going down a similar route as me, although with wider goals. I was just trying to
publish a crate with a trivial definition in it, and I don&#x27;t support all the
extra fields and secondary header stuff, or a way to include the CCSDS header into
another structure the way space_rust_library (or the pnet crate) do.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;publishing-a-crate&quot;&gt;Publishing a Crate&lt;&#x2F;h1&gt;
&lt;p&gt;Rust has been very friendly for me in a lot of ways so far. There is good information
on publishing a crate, and the process is very straightforward. Having the whole
thing built into cargo, including documentation, is just great. I know other
languages do things like this, but its still worth noting especially as I&#x27;m not
sure how they compare.&lt;&#x2F;p&gt;
&lt;p&gt;Its nice to see my documentation up there in the nice format that docs.rs puts them in,
even if the documentation itself is pretty minimal.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h1&gt;
&lt;p&gt;I published my first crate! My goal was to be a contributor and give something,
no matter how small, to the community. I hope someone (perhaps myself)
uses this crate one day, but even if they don&#x27;t, it feels good to share it.&lt;&#x2F;p&gt;
&lt;p&gt;Now I have to figure out what I want to do next. I would love
to be able to continue using Rust- its been a lot of fun! There are 
definitely projects I would like to work on, and having the control and knowledge
of memory layout combined with a certain amount of functional programming
sounds good to me!&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>Second Experience with Rust</title>
                <pubDate>Thu, 30 Aug 2018 00:00:00 +0000</pubDate>
                <link>https%3A//nsmryan.github.com/public/second-experience-with-rust/</link>
                <guid>https%3A//nsmryan.github.com/public/second-experience-with-rust/</guid>
                <description>&lt;p&gt;After my first pleasant but failed attempt to use Rust, I decided to try to
contribute a crate to the ecosystem. There are a lot of crates out there,
depsite the relative youth of the language, so I wanted to find something
that was not done and that I knew I could do. It had to be small- I don&#x27;t have 
a lot of time for working on things, and I wanted to be able to see it through
from start to finish. I wanted to see this crate have documentation, tests, and
an example like a good crate should.&lt;&#x2F;p&gt;
&lt;p&gt;People sometimes suggest definitions and a parser for a file format or network packet
that hasn&#x27;t been done before as a small project, so I decided to try to go through
route with CCSDS.  This is a progress report on a half finished library that provides
the primary header defined in the &lt;a href=&quot;https:&#x2F;&#x2F;public.ccsds.org&#x2F;Pubs&#x2F;133x0b1c2.pdf&quot;&gt;CCSDS Space Packet Protocol document&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;ccsds&quot;&gt;CCSDS&lt;&#x2F;h1&gt;
&lt;p&gt;The CCSDS Space Packet Protocol defines a very simple header called the primary
header, as well as a flag indicating whether another header follows.&lt;&#x2F;p&gt;
&lt;p&gt;This protocol is used in a lot of space systems, including the International Space
Station and many satellites. The header is really very simple, containing only:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;A version number, currently always 0&lt;&#x2F;li&gt;
&lt;li&gt;A flag indicating whether a second header follows. In my experience there is always
a secondary header, which usually provides a timestamp.&lt;&#x2F;li&gt;
&lt;li&gt;A flag indicating whether the packet is a command or a data (telemetry) packet. This is
an important distinction in space systems, which have an asymmetric communication path
and treat commands very differently from telemetry.&lt;&#x2F;li&gt;
&lt;li&gt;A number called an Application Identifier (APID, usually pronouced App-Id, or A-pid). This
is a project-specific number that identifies the packet, and in some projects identifies
the source, destination, and the packet type all in one number.&lt;&#x2F;li&gt;
&lt;li&gt;An enum identifying the interpretation of the sequence count. This can be used to split
large packets into several smaller ones. Usually packets are &amp;quot;unsegmented&amp;quot; and the sequence
count is just a counter, but it can be used to indicate a kind of block number is a series
of packets.&lt;&#x2F;li&gt;
&lt;li&gt;A sequence count (14-bits) whose intepretation is based on the sequence flag field above.&lt;&#x2F;li&gt;
&lt;li&gt;A packet length, giving the number of bytes after the primary header, not including the first
byte of data. This is a slightly strange choice- the length is not the length of the data section-
its the length of the data section minus 1. This is because CCSDS packets cannot have an
empty data section, so they must have at least 1 byte. The packet length is defined as the number
of bytes beyond the minimum required data section size. This often leads to increments and
decrements in code dealing with packet length to add in and take out this extra byte.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h1 id=&quot;the-crate-take-one&quot;&gt;The Crate, Take One&lt;&#x2F;h1&gt;
&lt;p&gt;My first attempt to write this crate went well- I found the parsing library
&lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;nom&#x2F;4.0.0&#x2F;nom&#x2F;&quot;&gt;nom&lt;&#x2F;a&gt; and assumed this was what I needed. In hindsight,
it was like using Haskell&#x27;s &lt;a href=&quot;http:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;parsec&quot;&gt;Parsec&lt;&#x2F;a&gt;
instead of &lt;a href=&quot;http:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;binary&quot;&gt;Binary&lt;&#x2F;a&gt;
or &lt;a href=&quot;http:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;cereal&quot;&gt;Cereal&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;I wrote a simple primary header struct, with enums for the sequence flags, the secondary
header flag, and the command&#x2F;data flag. This is essentially what I would have done in C,
except for the automatic deriving of a debug format, equality, and partial equality. I also
derived Copy and Clone because I think I&#x27;m supposed to, but I&#x27;m not sure- in C you would not
have to think about these things. In the Haskell approach you want to
derive a bunch of typeclasses to tie your data into the ecosystem and language a bit,
but I&#x27;m not sure what the right Traits to tie into are for Rust.&lt;&#x2F;p&gt;
&lt;p&gt;I wrote a Nom parser that could read off the primary header and put it into this struct.
I was able to get the Nom version working after some experimenting and looking at other crates.
I was used to the Haskell style where parser combinators are a data structure and we just
combine them with combinators and a Monad instance. The macro style felt unfamiliar and made
we worried that I didn&#x27;t understand what the code was doing since it defines a language
within Rust for defining these parsers, but I found it easy enough to use and for my
needs it was a simple task to get working.&lt;&#x2F;p&gt;
&lt;p&gt;Then I realized that I wanted to both read and write packets, and Nom was only for parsing.&lt;&#x2F;p&gt;
&lt;p&gt;Oh well, time for take two.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;the-crate-take-two&quot;&gt;The Crate, Take Two&lt;&#x2F;h1&gt;
&lt;p&gt;I looked around for how people do serializtion and deserialization in Rust. There are usually
two types of libraries for this task- ones that use a format like CBOR or a language-specific
format like EDN for Clojure where you want to serialize and deserialize data in your language,
and libraries that provide ways to lay out memory explicitly where you are going to 
transfer it over the network or interact with hardware. I&#x27;m usually in the second camp, where
the format I want isn&#x27;t one of the popular formats, and I have to lay out data explicitly in
memory. I&#x27;ve used Haskell&#x27;s binary for this, and of course done it in C many many times without
a library.&lt;&#x2F;p&gt;
&lt;p&gt;Looking for this kind of thing in Rust, I started to look at &lt;a href=&quot;https:&#x2F;&#x2F;serde.rs&#x2F;&quot;&gt;serde&lt;&#x2F;a&gt;.
However, it seems to only support these serialization formats, and not the explicit memory
use style. There are a number of different formats supported, and I like the idea that you
can break the language down into a small(ish) number of cases (like Haskell&#x27;s GHC Generics or
Generics SOP). The Rust equivalent seems to have a good number of cases (29 or something), but
still, I like that it is possible.&lt;&#x2F;p&gt;
&lt;p&gt;Ultimately I was able to search around crates.io until I found the
&lt;a href=&quot;https:&#x2F;&#x2F;carllerche.github.io&#x2F;bytes&#x2F;bytes&#x2F;index.html&quot;&gt;bytes&lt;&#x2F;a&gt; crate. This seems to be what
networking libraries are using in Rust, and the documentation is great. I&#x27;m used to the idea
of looking around at the data structures and what traits they implement from Haskell and its
typeclasses, so I was eventually able to piece together the story of how I would use bytes
to do CCSDS packets.&lt;&#x2F;p&gt;
&lt;p&gt;I wrote up this implementation and had the following experience:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Implementing the traits for quickcheck was easy enough, and I could test roundtripping
serialization&#x2F;deserialization. This found a couple bit shifting bugs in my implementation! Nice.&lt;&#x2F;li&gt;
&lt;li&gt;The Rust idiom of writing a From trait and getting a To trait works pretty well. In C, I would
have just cast enums and integers with no extra code, but I don&#x27;t mind writing more code
for more safety. In Haskell, I believe I would have been able to derive the Enum typeclass
and avoided some of this work, but its not too much trouble.&lt;&#x2F;li&gt;
&lt;li&gt;Testing is very easy in Rust. I don&#x27;t know why I find it easier then Haskell exactly,
except that the integration with cargo just seems simplier then &amp;quot;stack test&amp;quot;.&lt;&#x2F;li&gt;
&lt;li&gt;The bit shifting&#x2F;masking code seems very similar to C. I know there is a bitfield and a 
bitflag crate, but at the time I wanted to try out just doing this stuff by hard as I would
in C.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Overall, I was happy with the implementation. I don&#x27;t plan on publishing it though, as I realize
that I was forcing the user to deserialize their headers into a data structure with no
way to act on the raw bits as you would in C. I feel like in a large system I would want to
be able to pass packets around and not always have them in a deserialized form depending
on the use-case.&lt;&#x2F;p&gt;
&lt;p&gt;Oh well, time for take three.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;the-crate-take-three&quot;&gt;The Crate, Take Three&lt;&#x2F;h1&gt;
&lt;p&gt;Providing bit-level access to the header seems like it will require either a getter&#x2F;setter
pair for each field (&amp;quot;packet_type&amp;quot; and &amp;quot;get_packet_type&amp;quot;), or the use of the bitfields
crate. I have not yet completed this iteration, but I am going to work on providing
both the deserialized form of a primary header as a struct, and a bitfields version which
deals with the header on the bit level.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h1&gt;
&lt;p&gt;As part of my desire to contribute to the Rust community, I&#x27;m trying to write up my experience&lt;&#x2F;p&gt;
&lt;p&gt;Haskell in this regard because of Haskell [language-c][http:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;language-c]
library, which provides a nice way to parse C. I know you can use the Rust clang, but
I&#x27;m worried that with something as complex as a C AST I will get overwhelmed with
complexity if I don&#x27;t use Haskell.&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>First Experiences with Rust</title>
                <pubDate>Wed, 29 Aug 2018 00:00:00 +0000</pubDate>
                <link>https%3A//nsmryan.github.com/public/first-experiences-with-rust/</link>
                <guid>https%3A//nsmryan.github.com/public/first-experiences-with-rust/</guid>
                <description>&lt;p&gt;I&#x27;ve seen Rust mentioned here and there, but until recently I put off the investment
needed to learn it. Part of that was that I found the syntax a bit off-putting- 
some code seems perfectly reasonable, and other code is pretty intimidating
to a new-comer.&lt;&#x2F;p&gt;
&lt;p&gt;However, I have been thinking about safer embedded systems code, so of course Rust
entered the picture again. I wanted to write up my first experiences learning the
language, and hopefully continue to write about my journey.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;getting-started&quot;&gt;Getting Started&lt;&#x2F;h2&gt;
&lt;p&gt;As someone who uses C&#x2F;C++ for work, and who is interested in Haskell, I felt like
I should be able to learn Rust. So far, it does have some of the feeling of both
C and Haskell to me- more on that later.&lt;&#x2F;p&gt;
&lt;p&gt;I started with the &lt;a href=&quot;https:&#x2F;&#x2F;www.rust-lang.org&#x2F;en-US&#x2F;index.html&quot;&gt;Rust website&lt;&#x2F;a&gt;, of course,
and the &lt;a href=&quot;https:&#x2F;&#x2F;www.rust-lang.org&#x2F;en-US&#x2F;documentation.html&quot;&gt;documentation&lt;&#x2F;a&gt;. I found
that I could learn each concept with the example they give, and overall it was easy to
look through the major features of the language and get an idea of how to read a program.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;cargo&quot;&gt;Cargo&lt;&#x2F;h2&gt;
&lt;p&gt;It can be interesting to look over a languages package system (if it has one) to see what
the major libraries are and what topics the community has handled. There is a sense with
Rust of having some really great libraries, a lot of libaries in general, and a lot of
libraries with very good and consistent documentation. There is also a sense of
incompleteness, experimental libraries and libraries that are establishing themselves
in the ecosystem.&lt;&#x2F;p&gt;
&lt;p&gt;Many of the libraries I looked at either had very good documentation, or they were clear
that they were experimental and were not ready for widespread adoption.&lt;&#x2F;p&gt;
&lt;p&gt;As a Haskeller, I was interested in the Rust view of some major Haskell packages, like
quickcheck and parsec&#x2F;attoparsec. It looks like there is a quickcheck crate (which turns
out of be easy to use) as well as other implementations of the quickcheck concept,
and there are several ways to do parsing depending on your use-case, but Nom seems to
be the major parser combinator library. Some things, such as lens, do not appear to
be as established.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;tooling&quot;&gt;Tooling&lt;&#x2F;h2&gt;
&lt;p&gt;I was very impressed with how easy it is to set up a Rust environment, start a project,
add dependancies, and get something working. I found it very easy to add tests as part
of my development process, which is very nice to see.&lt;&#x2F;p&gt;
&lt;p&gt;I also very much liked being able to get a particular toolchain with rustup. I was able
to compile with the msvc toolchain and the gnu toolchain on Windows, and I had a very easy time
up installing the armv7-unknown-linux-gnueabihf and getting a Rust program to cross compile
for an ARM system I had in the lab at work. I have had some much trouble with this kind of thing
in the past with C programs, especially on Windows, that this was pretty significant for me.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;my-first-program&quot;&gt;My First Program&lt;&#x2F;h2&gt;
&lt;p&gt;I had wanted to do some simple profiling of a telemetry processing tool I wrote in C using the
LabWindows development environment. All I wanted was to instrument some places in my code and
get a sense of how long each stage of the program was taking, but I couldn&#x27;t find a tool that
was quite simple enough for me. I wanted to be able to instrument code on different operating
systems (VxWorks, Windows and Linux), and I really wanted something simple if possible.&lt;&#x2F;p&gt;
&lt;p&gt;Not finding anything to my liking, I thought it might be a fun thing to write up myself. I
tried to get the CFS&#x2F;CFE performancing monitoring work, in case I could use it as a baseline or
as a possible target for my library, but I ran into a number of issues with that path and
abandoned it.&lt;&#x2F;p&gt;
&lt;p&gt;I called the library Demark (like to demarcate something) and, inspired by C libraries like
jsmn, I gave it the minimal number of functions possible. You could start a log,
add an entry, and write out to a file. I ended up with some additional features to make
the resulting log more useful, but it was still a pretty small library.&lt;&#x2F;p&gt;
&lt;p&gt;I struggled for some time with certain things that are easy in C (perhaps to easy?) like
casting a pointer to a buffer to a pointer to a struct. The repr(C) directive works
as expected, and I found the mem::transmute to do the casting. I did fight with
borrowing&#x2F;ownership for a while, but I expected that at first. I&#x27;m still not completely
clear on how to manage that stuff, but better then at first.&lt;&#x2F;p&gt;
&lt;p&gt;In the end, I liked the Rust version of this library. It has the feeling of some of the
safety of Haskell, the pattern matching, the nice types, and immutable data. It also
has some of the feeling of C- I more-or-less know what my data looks like in memory,
when I&#x27;m allocating memory, using pointers, and feeling like you understand the cost
of your actions (again, more-or-less- I don&#x27;t have a deep understanding of the assembly
or anything). At first I was concerned that I wouldn&#x27;t always know when allocation
was occurring (this is very important to me) but I believe I will be able to control
allocation fairly easily and tell whether code allocates or not. I still have some
learning to do there. There is a great cheatsheet
&lt;a href=&quot;https:&#x2F;&#x2F;web.stanford.edu&#x2F;class&#x2F;cs140e&#x2F;notes&#x2F;lec3&#x2F;cheat-sheet.pdf&quot;&gt;here&lt;&#x2F;a&gt; which
I found a huge help. &lt;&#x2F;p&gt;
&lt;p&gt;I did have a strange feeling the first time I put a print statement in my code- it feels
enough like Haskell that I expected to have to control my side effects more.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-problems&quot;&gt;The Problems&lt;&#x2F;h2&gt;
&lt;p&gt;I did run into a number of problems integrating my library with some existing C code. In the
end, the 32 bit toolchain didn&#x27;t work because of some linking issue, and the 64 bit one didn&#x27;t 
work for reasons I can no longer remember. I also tried the msvc toolchain, but that ended up
creating a DLL that required a large number of dependancies that I didn&#x27;t want to fulfill
in a LabWindows program.&lt;&#x2F;p&gt;
&lt;p&gt;In the end, I just wanted something that worked, so I rewrote the code in C and ended up with
a simple profiling library and viewer. This helped me find some slow points in the code, and
I would use it in the future if I wanted to improve that telemtry processor again.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h2&gt;
&lt;p&gt;I would like to try Rust again- I am willing to put up with some rough edges and some initial
failures. I see a lot of potential, and I would love to be able to integrate Rust into my
everyday work. I could see trying to create some very fast tool, or experimenting with a small
software modules in Rust.&lt;&#x2F;p&gt;
&lt;p&gt;The interoperation with C is a huge selling point for me, and is perhaps the single enabling
feature of Rust for me to use it at work. I write a lot of C, and barriers to working with
C would make Rust a non-starter. Happily, I was pleased with the experiment even though it failed,
and I hope to contribute to Rust in the future.&lt;&#x2F;p&gt;
&lt;p&gt;I really like the emphasis on friendliness in the community- it is very important to me
to feel like a community will be friendly before I would consider contributing.&lt;&#x2F;p&gt;
&lt;p&gt;Thanks for reading!&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>Rust has the Best Names</title>
                <pubDate>Sun, 19 Aug 2018 00:00:00 +0000</pubDate>
                <link>https%3A//nsmryan.github.com/public/rust-has-the-best-names/</link>
                <guid>https%3A//nsmryan.github.com/public/rust-has-the-best-names/</guid>
                <description>&lt;p&gt;I&#x27;ve been looking into Rust recently, and I am finding that I like it, and that
I want to like it.&lt;&#x2F;p&gt;
&lt;p&gt;If nothing else, that language community choses the best names for things:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Rust&lt;&#x2F;li&gt;
&lt;li&gt;Deisal&lt;&#x2F;li&gt;
&lt;li&gt;Refraction&lt;&#x2F;li&gt;
&lt;li&gt;Iron&lt;&#x2F;li&gt;
&lt;li&gt;Nickel&lt;&#x2F;li&gt;
&lt;li&gt;Servo&lt;&#x2F;li&gt;
&lt;li&gt;Tendril&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;and probably many more. I just can&#x27;t help but like them.&lt;&#x2F;p&gt;
</description>
            </item>
        
    </channel>
</rss>
