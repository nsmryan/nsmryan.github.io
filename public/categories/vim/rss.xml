<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>itscomputersciencetime</title>
        <link>http%3A//nsmryan.github.com/public</link>
        <description></description>
        <generator>Zola</generator>
        <language>en</language>
        <atom:link href="http%3A//nsmryan.github.com/public/categories/vim/rss.xml" rel="self" type="application/rss+xml"/>
        <lastBuildDate>Thu, 02 May 2019 00:00:00 +0000</lastBuildDate>
        
            <item>
                <title>The Many Layers of Movement in Vim</title>
                <pubDate>Thu, 02 May 2019 00:00:00 +0000</pubDate>
                <link>http%3A//nsmryan.github.com/public/layers-of-movement-in-vim/</link>
                <guid>http%3A//nsmryan.github.com/public/layers-of-movement-in-vim/</guid>
                <description>&lt;p&gt;I have been teaching my twin brother Vim recently, which has lead to an insight- the
kind of insight you get when you are forced to articulate something that you only know implicitly.&lt;&#x2F;p&gt;
&lt;p&gt;The insight is that when I use Vim, I make use of as many as 4 separate &amp;quot;levels&amp;quot; of movement, each of which makes larger
jumps but is less accurate then the next level. Each level requires a separate set of commands, and mastering each set
makes programming as a whole much, much faster. I use Vim partially for speed, so this is very important for me.&lt;&#x2F;p&gt;
&lt;p&gt;This kind of movement is a very important part of text editing- a project can have thousands, tens of thousands,
perhaps millions of lines of text, and many millions of individual characters, and you need to get the cursor to
the exact character you need in order to start editing. This is greatly assisted by movements going from
very course to increasingly fine until you get where you want to go.&lt;&#x2F;p&gt;
&lt;p&gt;This is a process I have improved over the years, but certainly there are places I could improve
(especially through integration with plugins). Even so, with a couple plugins and a lot of bulit in Vim commands,
there is a lot of sublety in movement in Vim, multiple sets of commands, and optimization of the common case.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;move-between-source-locations-in-4-easy-steps&quot;&gt;Move Between Source Locations in 4 Easy Steps&lt;&#x2F;h1&gt;
&lt;p&gt;Vim, like many well-used tools, provides a series of differerent levels of precision depending on the task at handle.
To prevent unnecessary suspense, I will just list the levels of movement as I see them:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Movement between files&#x2F;buffers&lt;&#x2F;li&gt;
&lt;li&gt;Movement within a file&lt;&#x2F;li&gt;
&lt;li&gt;Movement within the screen&lt;&#x2F;li&gt;
&lt;li&gt;Movement within a line of text.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Not all levels are necessarily used- more that the levels exist and are useful in different situations. Its also worth
stating that you don&#x27;t necessarily have to move to an exact character to do a particular edit- deleting a line or
series of lines, for example, can be done by moving to the right line, regardless of the particular character.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;stage-1-the-file&quot;&gt;Stage 1- The File&lt;&#x2F;h2&gt;
&lt;p&gt;This stage gets you to the file you need to edit. If you are already there, skip to the next stage. 
Note that am not talking about moving between projects (which would come before moving between files)&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;I don&#x27;t have a good session manangement or project management solution for myself anyway.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;buffers&quot;&gt;Buffers&lt;&#x2F;h3&gt;
&lt;p&gt;For files, the main way I move to a file is using buffers. I used tabs for a good bit of time, but like many
people once I got used to buffers I never looked back. To move to a file that is in an open buffer, say a file
named &amp;quot;main.rs&amp;quot;, I might type:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212733;&quot;&gt;
&lt;span style=&quot;color:#ccc9c2;&quot;&gt;:b main&amp;lt;CR&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &#x27;&lt;CR&gt;&#x27; means pressing enter, as in Vim key-bindings..&lt;&#x2F;p&gt;
&lt;p&gt;This is very fast, as long as you know what file you want, you know a part of the file name that is not ambiguous, and 
the file is open in a buffer. One can also use the &#x27;edit&#x27; command:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212733;&quot;&gt;
&lt;span style=&quot;color:#ccc9c2;&quot;&gt;:e main.rs
&lt;&#x2F;span&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;If the file is not open, as long as you don&#x27;t mind typing the full path. I do this very rarely, as I use NerdTree for this
situation.&lt;&#x2F;p&gt;
&lt;p&gt;As with other levels, as we will see, there are commands to optimize the common case. There are commands to
go forward in the buffer list, backwards in the buffer list, and best of all to switch to the last file used. Even
these commands, optimized for the common case, are themselves optimized by providing short versions, like using
&#x27;:bn&#x27; for &amp;quot;:bnext&amp;quot;- command prefixes will be expanded automatically if they are unambiguous.&lt;&#x2F;p&gt;
&lt;p&gt;Something to notice about swapping buffesr is that the choice of the tab key is very quick, which makes it a great mapping
for switch buffers. Its especially good to have this mapping take only a single character, as I often want to flip
back and forth between files (even when using splits I sometimes toggle files in some situations).&lt;&#x2F;p&gt;
&lt;h3 id=&quot;nerdtree-file-explorer&quot;&gt;NerdTree (File Explorer)&lt;&#x2F;h3&gt;
&lt;p&gt;If a file is not in a buffer, I don&#x27;t know which one I want, or if I have to look around within directories, I open NerdTree
(mapped to &#x27;,n&#x27; for me). This is fast, and I can toggle it back within another &#x27;,n&#x27;. There is not much else to say- its a great plugin for looking over your project, opening files in several ways, and probably lots of things I don&#x27;t know about.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;ctrl-p-fuzzy-search&quot;&gt;Ctrl-P (Fuzzy Search)&lt;&#x2F;h3&gt;
&lt;p&gt;The last method I use for getting to a file is a fuzzy search tool called Ctrl-P. I just type &amp;quot;&lt;CTRL&gt;P&amp;quot; and type some piece
of the file name I want to open, and Ctrl-P will find files that seem like what I wanted. This is especially good for very complex,
nested projects where I don&#x27;t want to hunt around in 4 levels of hierarchy for a file whose name I already know all or part of.&lt;&#x2F;p&gt;
&lt;p&gt;This tool is amazing and I highly recommand it- I feel like my brief description doesn&#x27;t get across how important it can be for
productivity in larger projects.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;stage-2-the-screen&quot;&gt;Stage 2- The Screen&lt;&#x2F;h2&gt;
&lt;p&gt;The next stage is getting the text you want to edit within the current screen. I currently have 75 lines viewable, and over 220
columns, so splits are very nice in providing different views witihin files. How fast you get to the right lines within a buffer
can depend on your knowledge of the code, and whether you have edited that section recently.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;searching&quot;&gt;Searching&lt;&#x2F;h3&gt;
&lt;p&gt;To get a section of text within your current pane, the main thing I do is simply search. Either a &#x27;&#x2F;&#x27; or a &#x27;?&#x27; can usually get
you where you need to go quickly. There are some settings having to do with searching, like highlighting search results with:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212733;&quot;&gt;
&lt;span style=&quot;color:#ccc9c2;&quot;&gt;set hlsearch
&lt;&#x2F;span&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;or making it easy to clear the highlighting with&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212733;&quot;&gt;
&lt;span style=&quot;color:#ccc9c2;&quot;&gt;nmap &amp;lt;Leader&amp;gt;h :noh&amp;lt;CR&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;I&#x27;m no expert on all the other settings- see my vimrc for my personal configuration.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;jumps&quot;&gt;Jumps&lt;&#x2F;h3&gt;
&lt;p&gt;Another common type of movement is to just move the screen a certain amount up or down within the file. Again, there are several commands-&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&#x27;&lt;CTRL&gt;e&#x27; to move one line down (to the &lt;em&gt;e&lt;&#x2F;em&gt;nd of the file)&lt;&#x2F;li&gt;
&lt;li&gt;&#x27;&lt;CTRL&gt;y&#x27; to move one line up&lt;&#x2F;li&gt;
&lt;li&gt;&#x27;&lt;CTRL&gt;f&#x27; to move &lt;em&gt;f&lt;&#x2F;em&gt;orward a screen&lt;&#x2F;li&gt;
&lt;li&gt;&#x27;&lt;CTRL&gt;b&#x27; to move &lt;em&gt;b&lt;&#x2F;em&gt;ack a screen&lt;&#x2F;li&gt;
&lt;li&gt;&#x27;gg&#x27; to move to the top of a file&lt;&#x2F;li&gt;
&lt;li&gt;&#x27;G&#x27; to move to the bottom of a file.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;You can also just use the normal movement keys &#x27;j&#x27; or &#x27;k&#x27; if the cursor is at the bottom or top of the screen. If you like the simple &#x27;j&#x27; &#x27;k&#x27;
movements, use &#x27;H&#x27; or &#x27;L&#x27; to get to the top and bottom quickly without having to wait or type a line number.&lt;&#x2F;p&gt;
&lt;p&gt;Note that there are again course movements as well as fine movements- Vim provides a gradient of refinements that each provide a smoother
experience in a small way, adding up to a unique editing system (can you tell that I like Vim? I do like it, for all its arcane warts, weirdness,
and weaknesses).&lt;&#x2F;p&gt;
&lt;h3 id=&quot;marks&quot;&gt;Marks&lt;&#x2F;h3&gt;
&lt;p&gt;Another method that I use on occasion is marks- you can mark a location within a file and return to it at any time. You mark a location
by giving a letter, allowing 26 separate marks to be made within a file (I use between 1 and 3 for the most part). You can move to
the line a mark is on with &amp;quot;&#x27;&amp;quot; (single tick) and the exact cursor position with &#x27;&#96;&#x27; (back-tick).&lt;&#x2F;p&gt;
&lt;p&gt;A mark labeled with the
letter &#x27;a&#x27; is made by:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212733;&quot;&gt;
&lt;span style=&quot;color:#ccc9c2;&quot;&gt;ma
&lt;&#x2F;span&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;You return to the cursor position marked with the letter &#x27;a&#x27; by:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212733;&quot;&gt;
&lt;span style=&quot;color:#ccc9c2;&quot;&gt;&#96;a
&lt;&#x2F;span&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Which is a backtick (tilde key) followed by the character used when making the mark. Again, using &amp;quot;&#x27;a&amp;quot; would return to the line the mark is on,
which I actually learned while writing this article, after using Vim for around 10 years.&lt;&#x2F;p&gt;
&lt;p&gt;There are several markers that set themselves in certain situations.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;My favorite is &#x27;&#96;&#96;&#x27; which is two back-ticks, which returns to the location
before the last jump. This allows you to edit text, jump to a location you set, and then immediately jump back to where you where. This is very confusing
for anyone that is watching you. The next best mark is the &#x27;&#96;.&#x27; mark (back-tick and then dot) which moves to the last place that you edited text.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;This is a huge help in certain macros, where you need to mark locations that you move to and return to them, perhaps changing the text and remarking
for the next iteration of the macro. It provides a way for macros to communicate locations, which would have to be a whole other post.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;stage-3-the-line&quot;&gt;Stage 3- The Line&lt;&#x2F;h2&gt;
&lt;p&gt;The next stage of our journey is to the line of text we want to edit.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;absolute-and-relative-line-numbers&quot;&gt;Absolute and Relative Line Numbers&lt;&#x2F;h3&gt;
&lt;p&gt;There is always a way to get to the exact line of text you want to see, as long as you have line numbers enabled (&amp;quot;:set number&amp;quot;) or relative line numbers
(&amp;quot;set relativenumber&amp;quot;). If you are on line 10, and you want to go to line number 55, either type:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&#x27;:55&lt;CR&gt;&#x27; which jumps to the absolute line number 55.&lt;&#x2F;li&gt;
&lt;li&gt;&#x27;55G&#x27; which does the same thing- jumps to the absolute line number 55. I tend to use the command mode method, but I may retrain myself as the &#x27;G&#x27; method
is fewer keystrokes.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;To move a relative number, like down 40 lines, simply type &#x27;40j&#x27;. This repeats the movement &#x27;j&#x27; 40 times, and works with other movements and commands as well.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;course-jumps&quot;&gt;Course Jumps&lt;&#x2F;h3&gt;
&lt;p&gt;There are keys to move to certain regions of the screen:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&#x27;H&#x27; moves to the &lt;em&gt;H&lt;&#x2F;em&gt;igh part of the screen (the top).&lt;&#x2F;li&gt;
&lt;li&gt;&#x27;M&#x27; moves to the &lt;em&gt;M&lt;&#x2F;em&gt;iddle of the screen.&lt;&#x2F;li&gt;
&lt;li&gt;&#x27;L&#x27; moves to the &lt;em&gt;L&lt;&#x2F;em&gt;ow part of the screen (the bottom line).&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;This won&#x27;t get you to the line you want, but it might be close enough for a few &#x27;j&#x27;s or &#x27;k&#x27;s to get you there. It can also narrow the distance for other
movements like a search to make it more likely that you will get to where you want to go quickly.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;search&quot;&gt;Search&lt;&#x2F;h3&gt;
&lt;p&gt;As with finding text in a file, searching can be used to move to text on the screen. This is especially helpful there is something unique on that line that you 
can search for and get to quickly without having to move between search results or type a long search string.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;simple-movement&quot;&gt;Simple Movement&lt;&#x2F;h3&gt;
&lt;p&gt;Of course, you can always just &#x27;j&#x27; and &#x27;k&#x27; around if you are not up for fancy commands. I will often guess how many lines I need to move and type something like
&#x27;15k&#x27; or &#x27;15j&#x27;, and see how well I did.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;stage-4-the-character-within-a-line&quot;&gt;Stage 4- The Character Within a Line&lt;&#x2F;h2&gt;
&lt;p&gt;This stage moves the cursor within a line, and like all the previous stage has its own set of commands. In a certain sense I distinguish between moving within 
a block of characters and moving within blocks- this comes up within source code fairly often. There are commands that treat punction different that facilitate
these two types of movement.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;ends-of-line&quot;&gt;Ends of Line&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;&#x27;0&#x27; to move to the beginning of the line.&lt;&#x2F;li&gt;
&lt;li&gt;&#x27;^&#x27; to move to the first non-space character of the line.&lt;&#x2F;li&gt;
&lt;li&gt;&#x27;$&#x27; to move to the end of the line.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;within-a-line&quot;&gt;Within a Line&lt;&#x2F;h3&gt;
&lt;p&gt;The following commands move within a line. Note that many can be repeated by prefixing them with a number.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&#x27;W&#x27; to move a &lt;em&gt;W&lt;&#x2F;em&gt;ord forward.&lt;&#x2F;li&gt;
&lt;li&gt;&#x27;B&#x27; to move a word &#x27;B&#x27;ackward.&lt;&#x2F;li&gt;
&lt;li&gt;&#x27;f&#x27; to move &#x27;f&#x27;orward to a character, such as typing &#x27;f(&#x27; to move the cursor to the next open parenthesis.&lt;&#x2F;li&gt;
&lt;li&gt;&#x27;F&#x27; to move &#x27;F&#x27; backwards to a character, such as typing &#x27;F(&#x27; to move the cursor to the previous open parenthesis.&lt;&#x2F;li&gt;
&lt;li&gt;&#x27;t&#x27; to move &#x27;t&#x27;oward a character, such as typing &#x27;t(&#x27; to move the cursor to just before the next open parenthesis.&lt;&#x2F;li&gt;
&lt;li&gt;&#x27;T&#x27; to move &#x27;T&#x27; backwards to a character, such as typing &#x27;T(&#x27; to move the cursor to just before the previous open parenthesis.&lt;&#x2F;li&gt;
&lt;li&gt;&#x27;h&#x27; to move one character to the left.&lt;&#x2F;li&gt;
&lt;li&gt;&#x27;l&#x27; to move one character to the right.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;There is also a plugin &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;justinmk&#x2F;vim-sneak&quot;&gt;&#x27;vim-sneak&#x27;&lt;&#x2F;a&gt; that I never got used to but seems like a good augmentation to Vim for this kind of movement.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;what-to-do-when-you-find-the-character-you-were-looking-for&quot;&gt;What to do When You Find The Character You Were Looking For&lt;&#x2F;h1&gt;
&lt;p&gt;Okay, so we have managed, through a long complex process requiring many separate decisions, to move a cursor to a character within a file. Congradulations!
Maybe its time to take a break, or drink a cup of tea.&lt;&#x2F;p&gt;
&lt;p&gt;To be serious, it seems like the complexity might be overwhelming for someone new to Vim, but its something that can be learned slowly over time,
and Vim will be productive the whole time you are learning after the initial learning curve.&lt;&#x2F;p&gt;
&lt;p&gt;What commands we have access to to actually edit text once we are where we want to go is outside the scope of this article- maybe another day.&lt;&#x2F;p&gt;
&lt;p&gt;Thank you for reading!&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>My Current Toolset</title>
                <pubDate>Tue, 11 Jul 2017 00:00:00 +0000</pubDate>
                <link>http%3A//nsmryan.github.com/public/my-current-tool-set/</link>
                <guid>http%3A//nsmryan.github.com/public/my-current-tool-set/</guid>
                <description>&lt;p&gt;I&#x27;ve accumulated a certain set of tools over the years for various aspects of programming and for various programming tasks.
I like to look at other peoples tools and configurations, so I figured I should talk about my own.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;vim&quot;&gt;Vim&lt;&#x2F;h1&gt;
&lt;p&gt;As mentioned on this blog, I use vim for text editing. I have become much more proficient in the last year, using a number of plugins 
and new techinques (new to me) like using only buffers and forgoing tabs.&lt;&#x2F;p&gt;
&lt;p&gt;I use vim for several reasons- it is fast, configurable, and has a lot of useful built-in command and great plugins. It may not be the
best possible text editor in all ways, and I may move on one day (perhaps just to neovim) but it has served me well these many years.
I can edit text faster, ensure more consistent style, perform transformations on data, view and edit raw binary data, and many other 
tasks far faster then I would be able to. Its a huge win in so many ways, and I do not regret in the slightest the modest investment of 
effort required to become proficient in it.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;c-c&quot;&gt;C&#x2F;C++&lt;&#x2F;h1&gt;
&lt;p&gt;For embedded systems work, I use C and a limit amount of C++. The C++ I have seen in these system is a tiny corner of the full language-
don&#x27;t expect lambdas, templates, or even inherence to come up.&lt;&#x2F;p&gt;
&lt;p&gt;I find C a sharp scalpal to use for this kind of work- its easy to do a lot of tasks that are tedious in other languages when dealing with
hardware and externally defined data, but the techniques and means of expression are very limited for many tasks. I don&#x27;t see an alternative
right now, even with some contenders that seem to be getting some use like Simulink.&lt;&#x2F;p&gt;
&lt;p&gt;I also use C for certain other tasks, like ground tools that interact directly with binary data produced by an embedded system or deal with hardware
that only has a C API. For these tasks it can be surprisingly straightfoward to use with the right environmnent (see LabWindows below).&lt;&#x2F;p&gt;
&lt;h1 id=&quot;labwindows&quot;&gt;LabWindows&lt;&#x2F;h1&gt;
&lt;p&gt;LabWindows is a development enviroment for C that comes with a visual GUI builder and a lot of libraries and utilities. The development environment
has a very nice debugger, which is missing a lot of the time on the systems I use. The GUI has a lot of controls and the utilities have been adaquate
for my needs in building simulators, configuration tools, ground systems, and algorithm visualizations.
I can get a GUI program set up and running in an afternoon which can easily interact with an embedded system, which is a niche that I am quite
happy to have filled.&lt;&#x2F;p&gt;
&lt;p&gt;Being pure C has advantages-
it is simple, it is compatable with a lot of hardware, and its easier to share code between an embedded system and LabWindows as long as you ensure
that your embedded systems code or headers files are pure C even in a C++ project. I&#x27;m sure it could be made more typesafe and concise, but
simplicity is nice in this niche- the cognitive overhead is not too much and I can concentrate on the task at hand for the most part.&lt;&#x2F;p&gt;
&lt;p&gt;Note that LabWindows is not free- its a tool that I learned about at work and is paid for by NASA. I don&#x27;t use it outside of work and I don&#x27;t think
I ever will, which is a shame to say about a tool you invest time in learning.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;r&quot;&gt;R&lt;&#x2F;h1&gt;
&lt;p&gt;I have picked up R as a way to do statistics, plotting (the plot command and ggplot2), data analysis and exploration.
There are a lot of libraries, and the user experience is very good.  I&#x27;ve had very few problems installing libraries and getting them to work.
The documentation has been adaquate, although sometimes lacking in some key examples.&lt;&#x2F;p&gt;
&lt;p&gt;One great thing about R is the ability to get your data processing and plotting into a script. In excel, the results of your efforts are encoded into the contents
of the spreadsheet. Even using formulas isn&#x27;t enough- you lose the thread of execution that gets you from your input to your output in a maze of columns and references.
With R, the logic is in a program, the data is in an easy enough form to use (usually dataframes, although I&#x27;m sure I&#x27;m missing out by not using more advanced libraries).&lt;&#x2F;p&gt;
&lt;p&gt;One of my major complaints with R is that it can be difficult to tell what a function will do at times. It seems to be a do-as-I-mean language, where functions
will often attempt to do the right thing with the input they are given, which can make it hard to determine exactly what it is they did do. This is fine when
things work, but when they do not, you have to track down exactly which path will be taken. This comes up especially often when I have something returned
by a library function and I&#x27;m passing it to another library function- what will this function do with the type of object returned by this other function?&lt;&#x2F;p&gt;
&lt;h1 id=&quot;excel&quot;&gt;Excel&lt;&#x2F;h1&gt;
&lt;p&gt;I felt that Excel deserves a mention here. I don&#x27;t particularly like using it, and I will use R when possible. Excel may not be the best, it may not be
able to operate on very much data without slowing down, it might not have all the formulas I need, or the ability (to the best of my knowledge) to
create repeated graphs or act on a series of separate data sets conviently, but it still has a use.&lt;&#x2F;p&gt;
&lt;p&gt;The main thing Excel does is allow you to explore your data quickly- even in R I have to write an expression to dsecribe what I want to see, but in Excel
I can plot, jump to cells, and quickly get a series of different views on a certain amount of data. &lt;&#x2F;p&gt;
&lt;p&gt;One other advantage is that while R lets you encode your processing in a program, if you do too much exploration from the command line then your progress is
somewhat lost unless you take the time to put it into a script. In contrast, in Excel your actions are recorded in cells and you leave a trail as you go. As I said
above, its not the best trail to follow, but at least the data is all there, visible, and persisting the calculations I did when exploring a data set with no
extra effort on my part.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;haskell&quot;&gt;Haskell&lt;&#x2F;h1&gt;
&lt;p&gt;Haskell is my hobby language, and every so often my language for tools that need to do parsing, complex algorithms, or small data handling tasks.
For work tasks, its great for parsing (I&#x27;ve used attoparsec for large, custom log files from COTS hardware), parsing custom binary data for statistics
and reporting, and streaming data (I use pipes, but I&#x27;m sure conduit would also work). I find that the types guide me to correct implementations,
find my mistakes, and teach me about my problem domain.&lt;&#x2F;p&gt;
&lt;p&gt;For hobby projects, its great for encoding ideas, teaching my about type theory, category theory, and other amazing things.&lt;&#x2F;p&gt;
&lt;p&gt;I know I can be productive in Haskell, my programs will be far more stable and robust then with my other options, and I will encode the problem
I am solving more concisely and with more clarity with the help of its type system then I would be able to in other languages.&lt;&#x2F;p&gt;
&lt;p&gt;In an engineering capacity I have to use the tool best suited for the job, so as much as I would use Haskell in every project, I often work in other languages.&lt;&#x2F;p&gt;
&lt;p&gt;My main complaint with Haskell is the occasional lack of a library which, say, Python or R might have.
I would like to say I&#x27;ve contributed a library when it was missing and helped the ecosystem, but to my shame I have not.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;python&quot;&gt;Python&lt;&#x2F;h1&gt;
&lt;p&gt;Python has occasionally filled a niche left by the other languages in my list. Its got a lot of packages available, including bindings to C libraries.
Its an easier sell than Haskell for a tool that other people will use. I have not used it much, but increasingly there is a gap between the high level Haskell tools
I write for small, specialized tasks, and the low level C programs which Python fills.&lt;&#x2F;p&gt;
&lt;p&gt;My biggest complaint with Python is the type system- its like I have my hands typed behind my back compared to Haskell. I can&#x27;t reason locally about my code- I have
to understand the whole program and its inputs and outputs to understand what happens within a function. The reasoning is about the dynamic behavior of the program
and not its specification, and the larger the program the worse this becomes. Its the right choice for me for some programs, but I do wish it could do more to help
me with my programs.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;tmux&quot;&gt;Tmux&lt;&#x2F;h1&gt;
&lt;p&gt;I&#x27;ve been using tmux recently, just to make my development environment in Cygwin (at work) and in Linux (at home) a little nicer. I don&#x27;t have much else to say- its very good
and easier and the vim interoperation has been enough for my needs.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h1&gt;
&lt;p&gt;This is not a list of all languages or programs that I use- its just my toolbox for common tasks, and the tools are what I reach for most often.&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>Vim Keybinding and Options</title>
                <pubDate>Sat, 15 Oct 2016 00:00:00 +0000</pubDate>
                <link>http%3A//nsmryan.github.com/public/vim-keybindings/</link>
                <guid>http%3A//nsmryan.github.com/public/vim-keybindings/</guid>
                <description>&lt;p&gt;If you are interested in improving your productivty with Vim, its worth checking out
other people&#x27;s .vimrc files. There are many github repositories with personal dot files,
including my own &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;nsmryan&#x2F;ConfigFiles&quot;&gt;config files&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;One that has helped me a lot is begriff&#x27;s
&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;begriffs&#x2F;haskell-vim-now&#x2F;blob&#x2F;master&#x2F;.vimrc&quot;&gt;haskell-vim-now&lt;&#x2F;a&gt;
and blaenk&#x27;s &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;blaenk&#x2F;dots&quot;&gt;dot files&lt;&#x2F;a&gt;. Incidentally, their blogs
&lt;a href=&quot;https:&#x2F;&#x2F;begriffs.com&#x2F;&quot;&gt;begriffs&lt;&#x2F;a&gt; and &lt;a href=&quot;http:&#x2F;&#x2F;www.blaenkdenum.com&#x2F;about&#x2F;&quot;&gt;blaenkdenum&lt;&#x2F;a&gt;
are worth checking out.&lt;&#x2F;p&gt;
&lt;p&gt;I thought I would go over some of my configuration, covering both old and new features
that I find useful.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h1 id=&quot;comma-as-leader&quot;&gt;Comma as Leader&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;strong&gt;nnoremap ,, ,&lt;&#x2F;strong&gt;
&lt;strong&gt;let mapleader=&amp;quot;,&amp;quot;&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I used ** as the leader key for several years before moving to &lt;strong&gt;,&lt;&#x2F;strong&gt;. I find that &lt;strong&gt;,&lt;&#x2F;strong&gt; is
easier to type because it is closer to the home row. This is a minor change, but making
custom key bindings behind leader easier to type makes you use them more, so its important
to find a key that works well for you.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;relative-line-numbers&quot;&gt;Relative Line Numbers&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;strong&gt;set invrelativenumber&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;First of all, &lt;strong&gt;set number&lt;&#x2F;strong&gt; puts line numbers on the left side of a window. I thought this
was what I wanted, but it turns out that absolute line numbers are less useful than relative
line number: &lt;strong&gt;set invrelativenumber&lt;&#x2F;strong&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;This took some getting used to, and I almost went back to absolute numbers. However, after a
while something clicked for me and I almost never use absolute line numbers anymore.
Relative line numbers are much better for navigation- vim motion commands that take line
numbers often need relative numbers. Now I can look at a line and see the number I need to
type to get there with &lt;strong&gt;j&lt;&#x2F;strong&gt; or &lt;strong&gt;k&lt;&#x2F;strong&gt;. This is also useful in line selection mode.&lt;&#x2F;p&gt;
&lt;p&gt;I did map ,er to toggle relative line numbers for when I do care about absolute line numbers,
like during a code review.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;highlight-search&quot;&gt;Highlight Search&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;strong&gt;set hlsearch&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The option &lt;strong&gt;set hlsearch&lt;&#x2F;strong&gt; highlights the current search term. This is useful for finding
occurrances of a pattern, like highlighting tabs with &lt;strong&gt;&#x2F;\t&lt;&#x2F;strong&gt; or uses of a variable name that
is under the cursor with &lt;strong&gt;*&lt;&#x2F;strong&gt;. You can remove the highlighting of the last search with &lt;strong&gt;:noh&lt;&#x2F;strong&gt;,
or map it to something like &lt;strong&gt;,h&lt;&#x2F;strong&gt;.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;leave-insert-mode&quot;&gt;Leave Insert Mode&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;strong&gt;inoremap jj &lt;ESC&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I found a nice trick for quickly leaving insert mode without typing &lt;strong&gt;ctrl-esc&lt;&#x2F;strong&gt;. I&#x27;ve been
using &lt;strong&gt;ctrl-[&lt;&#x2F;strong&gt; for almost as long as I&#x27;ve been using vim to avoid having to move up to
the esc key, but recently I&#x27;ve also added &lt;strong&gt;jj&lt;&#x2F;strong&gt; as an option. This key combination almost
never comes up, and it is easy to type. This cuts down on using my pinky fingers which reduces
the strain on my hands.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;saving-current-file&quot;&gt;Saving Current File&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;strong&gt;nmap &lt;Leader&gt;m :w&lt;CR&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Typing &lt;strong&gt;:w&lt;esc&gt;&lt;&#x2F;strong&gt; is another key combination that can strain my hands, especially since I&#x27;m a
compulsive saver. I have conciously reduced the number of times I save, but I&#x27;ve also added
the key binding &lt;strong&gt;,m&lt;&#x2F;strong&gt; as a quick and easy alternate to &lt;strong&gt;:w&lt;&#x2F;strong&gt;. This works well with the previous
binding &lt;strong&gt;jj&lt;&#x2F;strong&gt; so I can type &lt;strong&gt;jj,m&lt;&#x2F;strong&gt; to leave insert mode and save my changes.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;select-last-paste&quot;&gt;Select Last Paste&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;strong&gt;nmap &lt;Leader&gt;v V&#96;]&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I find that I frequently need to edit text that I&#x27;ve just pasted- either to realign it or
reformat in some way. There is already &lt;strong&gt;V&#96;]&lt;&#x2F;strong&gt; for this, but I find it easier to remember &lt;strong&gt;,v&lt;&#x2F;strong&gt;.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;buffers&quot;&gt;Buffers&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;strong&gt;set hidden&lt;&#x2F;strong&gt;
&lt;strong&gt;map &lt;C-j&gt; :bnext&lt;CR&gt;&lt;&#x2F;strong&gt;
&lt;strong&gt;map &lt;C-k&gt; :bprev&lt;CR&gt;&lt;&#x2F;strong&gt;
&lt;strong&gt;nmap &lt;Tab&gt; :b#&lt;CR&gt;&lt;&#x2F;strong&gt;
&lt;strong&gt;nmap &lt;Leader&gt;et :e %:p:s,.h$,.X123X,:s,.cpp$,.h,:s,.X123X$,.cpp,&lt;CR&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;I used tabs for years before understanding the advantages of buffers. If you still use tabs,
or use neither, I highly recommend trying out buffers for a while. This has been one of the
biggest changes in my workflow- I can&#x27;t stress it enough. My workflow with tabs was clunky
and didn&#x27;t scale well. With buffers, once you are used to moving between them, you can have
a huge number of open files and still navigate. The speedup using buffers in vim compared to
tabs in vim or in an IDE (I use eclipse at work) is huge.&lt;&#x2F;p&gt;
&lt;p&gt;To facilitate using buffers, I recommend the &lt;strong&gt;set hidden&lt;&#x2F;strong&gt; option to allow buffers to be
open with unsaved changes. Without this, buffers would be a huge pain to use.
I also recommend addding key bindings to cycle through buffers. You will usually use &lt;strong&gt;:b&lt;&#x2F;strong&gt; and
either the buffer number (use &lt;strong&gt;:ls&lt;&#x2F;strong&gt; to get a list of buffers and their numbers) or part of the
file name to switch better buffers. However, if you have two files open, or you need to look
through all open files, its nice to have a quick cycling keybinding.&lt;&#x2F;p&gt;
&lt;p&gt;I use &lt;strong&gt;ctrl-j&lt;&#x2F;strong&gt; and &lt;strong&gt;ctrl-k&lt;&#x2F;strong&gt; for cycling, and &lt;strong&gt;tab&lt;&#x2F;strong&gt; for switching with the 
last buffer viewed. I also have a map I found online for &lt;strong&gt;,et&lt;&#x2F;strong&gt; to toggle between .h and .cpp
files since I use C++ at work. This finds the file with the same name but the opposite extension
and switches to that buffer, if it is already open.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;don-t-redraw&quot;&gt;Don&#x27;t Redraw&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;strong&gt;set lazyredraw&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;This option prevents redrawing the screen while vim is executing macros. I often use macros to 
reformat huge text files (often datasets) at work, and I&#x27;ve found that redrawing the screen 
slows these down a huge amount. I used to just minimize the vim window, but this option makes 
this easier by preventing the redraws in the first place.&lt;&#x2F;p&gt;
&lt;p&gt;If this is a problem for you, I also recommend using the &lt;strong&gt;:g&lt;&#x2F;strong&gt; command and &lt;strong&gt;:s&lt;&#x2F;strong&gt; when possible-
they are much faster even on files with millions of lines.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;don-t-show-hit-enter-prompts&quot;&gt;Don&#x27;t Show &amp;quot;Hit Enter&amp;quot; Prompts&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;strong&gt;set shortmess=a&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;If you find the &amp;quot;Hit Enter&amp;quot; prompt that comes up when there are messages to confirm, then set 
this option. It will supress these prompts. You can always use &lt;strong&gt;:messages&lt;&#x2F;strong&gt; if you want to
review the messages anyway.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;hex-editor&quot;&gt;Hex Editor&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;strong&gt;nnoremap &lt;C-H&gt; :call ToggleHex()&lt;CR&gt;&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;You can find a definition for a function ToggleHex on the &lt;a href=&quot;http:&#x2F;&#x2F;vim.wikia.com&#x2F;wiki&#x2F;Improved_Hex_editing&quot;&gt;vim wiki&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;This keybinding toggles between viewing a file as hex and viewing it as text. I&#x27;ve been using
this for years, and although its not the best hex editor in the world, I do like having the
power of vim when viewing and editing hex.&lt;&#x2F;p&gt;
&lt;p&gt;This binding is mostly useful if you deal with binary formats frequently- I do embedded systems
programming at work so this comes up all the time. These are better editors out these, including
some quite expensive ones, but this one command gives me most of what I want without a separate
program.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;Thats some of the bindings and options I use often. There are many others, some much more
sophisticated then mine. A .vimrc file accumulates features over the years, and every so often
its worth looking them over and deciding what you need to automate to write better code, what
you spend the most time doing, and what small tweaks make your editing experience better.&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>My Vim Plugins</title>
                <pubDate>Sat, 15 Oct 2016 00:00:00 +0000</pubDate>
                <link>http%3A//nsmryan.github.com/public/vim-plugins/</link>
                <guid>http%3A//nsmryan.github.com/public/vim-plugins/</guid>
                <description>&lt;p&gt;I&#x27;ve been using vim&#x2F;gvim for about 8 or 9 years now, but I stopped improving my
vim experience after I reached a certain level of proficiency.
Recently I&#x27;ve made some huge improvements to my vim workflow that has rekindled my interest
in vim and made my daily life much better.&lt;&#x2F;p&gt;
&lt;p&gt;I have nearly 30 plugins right now, but I thought I would list some of the more important
ones here. My hope is that this helps someone else improve their vim experience.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;plug&quot;&gt;Plug&lt;&#x2F;h1&gt;
&lt;p&gt;I tried several plugin managers, and I was using Vundle for a while. However, I found that
it didn&#x27;t work well on Windows, and instead of messing around with it I started using the
very simple Plug plugin. Now I just list the plugins in want in my .vimrc, and when I need to
update to setup a new system I just run :PlugInstall and watch it download all my plugins.&lt;&#x2F;p&gt;
&lt;p&gt;Nice.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;ctrl-p&quot;&gt;Ctrl-P&lt;&#x2F;h1&gt;
&lt;p&gt;This plugin gives you a fuzzy file search with the default keybinding ctrl-p. This means that
you can type &amp;quot;ctrl-p cabal&amp;quot;, for example, and it will list the files with that name. You can
select a file and press enter to open it in a new buffer. This is much faster for opening new
files if you know the name of the file you want to open.&lt;&#x2F;p&gt;
&lt;p&gt;If you don&#x27;t know the name, or you want to explore files, there is always NERDTree.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;nerdtree&quot;&gt;NERDTree&lt;&#x2F;h1&gt;
&lt;p&gt;I finally installed NerdTree, which is a much better file explorer then the build in
one in vim. I have it mapped to ,n to toggle the left pane with the file explorer.&lt;&#x2F;p&gt;
&lt;p&gt;I also have been using rooter to set the current directory, which makes using NERDTree even nicer
because it always opens in the current directory, or in the root of the current project.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;rooter&quot;&gt;Rooter&lt;&#x2F;h1&gt;
&lt;p&gt;This one just sets the current directory to the project root. It detects certains files
(which is extendable) to determine where the root directory is. These are things like
source control configuration files, but you can add .cabal or any other file if it makes
sense for your project.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;solarized&quot;&gt;Solarized&lt;&#x2F;h1&gt;
&lt;p&gt;I used the colorscheme desert for a long time, but it is not perfect. Some research revealed the
colorscheme Solarized. I recommend it for most tasks.
The color of comments or plain text is a little light for me, so I also have the colorscheme
corporation installed, and I switch between them with ,ec for corporation and ,eo for solarized.
For example, I&#x27;m writing this post in corporation because on this monitor the white text is
sharp and visible, while on my work computer it is too bright and I would use solarized.&lt;&#x2F;p&gt;
&lt;p&gt;Both use very rich oranges and some nicely desaturated colors which I find very pleasing to look at.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;tabular&quot;&gt;Tabular&lt;&#x2F;h1&gt;
&lt;p&gt;The code I write for work (C&#x2F;C++ embedded system code for space and aero at NASA) has become must
better formatted since I found tabular. I usually use it to select a couple of lines of code
and align them on &amp;quot;=&amp;quot; or &amp;quot;,&amp;quot;.&lt;&#x2F;p&gt;
&lt;p&gt;It may seem like a small thing, but making good formatting easy means that I do it more often, and
its a noticable difference in the code I produce.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;tagbar&quot;&gt;Tagbar&lt;&#x2F;h1&gt;
&lt;p&gt;This is a fantastic plugin that gives you a bar displaying the symbols defined in your code.
This is something I used to miss from eclipse when using vim but no longer!&lt;&#x2F;p&gt;
&lt;p&gt;I have it mapped to &amp;quot;,g&amp;quot; so I can toggle it on and off. Screen space is too precious to keep it
up all the time, but its great to have when you want it.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;others&quot;&gt;Others&lt;&#x2F;h1&gt;
&lt;p&gt;I have also installed Fugitive, sneak, easy-motion, syntastic, ack, vim-textobj-user, and some
Haskell specific plugins like ghc-mod, haskell-vim, and neco-ghc. I haven&#x27;t looked into these
much, but the whole text-obj concept is worth looking into to understand vim, ack seems like
a huge help in finding things in large projects, syntastic closes the gap for me between vim
and an IDE, and sneak and easy-motion seem nice in principal even though I haven&#x27;t been using them
much.&lt;&#x2F;p&gt;
&lt;p&gt;That is a selection of the plugins I have found interesting. I have also found some keybindings
and vim tricks recently that I will discuss in another post.&lt;&#x2F;p&gt;
</description>
            </item>
        
    </channel>
</rss>
