<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>itscomputersciencetime</title>
        <link>https%3A//nsmryan.github.com/public/</link>
        <description></description>
        <generator>Zola</generator>
        <language>en</language>
        <atom:link href="https%3A//nsmryan.github.com/public/categories/functional-programming/rss.xml" rel="self" type="application/rss+xml"/>
        <lastBuildDate>Wed, 25 Jan 2017 00:00:00 +0000</lastBuildDate>
        
            <item>
                <title>Pure Functions in Embedded Systems Programming</title>
                <pubDate>Wed, 25 Jan 2017 00:00:00 +0000</pubDate>
                <link>https%3A//nsmryan.github.com/public/pure-functions-in-embedded-systems-programming/</link>
                <guid>https%3A//nsmryan.github.com/public/pure-functions-in-embedded-systems-programming/</guid>
                <description>&lt;p&gt;I&#x27;ve had some experiences recently where I&#x27;ve seen code written in C&#x2F;C++ for embedded systems
that benefited from my experiences with Haskell. In short, I&#x27;ve found that pure functions make code more robust, easier to test,
easier to document, easier to reason about, and easier to extend to new situations (porting between systems, and wrapping in simulators&#x2F;ground systems)
and changing requirements.  The only thing I&#x27;ve regretted using this technique is that I don&#x27;t do enough of it.&lt;&#x2F;p&gt;
&lt;p&gt;This post describes some of my experiences factoring out portions of
my code into pure functions on Class B and Class B Safety Critical software. There are other applications of functional programming and type theory
to embedded systems programming, but this is a big one.&lt;&#x2F;p&gt;
&lt;p&gt;Some examples from my experience are fault detection systems (Fault Detection, Isolation, and Recovery or FDIR), core algorithms like
orbit propagation (as well as boundary determination in a geofencing system, predicting vehicle dynamics and other such algorithms), input
accepting systems for communication like state machines, validation functions for data, converting data (including packetizing it, converting
between time formats, and parsing configuation), and applying filters to data or packets. Some of these applications are described in more detail below.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;pure-functions&quot;&gt;Pure Functions&lt;&#x2F;h1&gt;
&lt;p&gt;Briely, a pure function should will always produce the same result for the same input, regardless of when or how many times it is run.
This prevents IO, global state, network traffic etc- anything that might modify how a function runs or make it non-deterministic.
This is a situation where restricting what you make use of is a hugely powerful technique, and having the discipline to
enfore purity (even in a language which does nothing to help you do that) yields huge benefits that pay for the time invested many times over.&lt;&#x2F;p&gt;
&lt;p&gt;In embedded systems, software is written as a series of modules, each with a particular task or roles within the system. Look at
Core Flight Software (CFS) for an example of this kind of architecture. Within this architecture, there tend to be several types of modules. Some examples are
modules that that perform software tasks (ie routing messages, packaging data, monitoring telemetry), modules that provide utility functions,
modules that run a particular algorithm, and modules that interface with hardware.&lt;&#x2F;p&gt;
&lt;p&gt;All of these modules can benefit from pure functions. Code that does not need to interface with hardware (utilities and algorithms) is especially good for this
kind of design, but even modules that interface with hardware can section off parts of their processing into pure functions and get the benefits.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;fdir&quot;&gt;FDIR&lt;&#x2F;h1&gt;
&lt;p&gt;A concrete example is a fault detection system that takes a series of structures defining what to monitor, and recieves a packet to inspect at a given rate.
This kind of system benefits from factoring all the monitoring code out into pure functions which apply single monitors. With that design, test cases can produce
a variety of things to monitor throughout a packet, and feed both the packet and what to look for within that packet, into a single function. The result can be
automatically inspected, and the resulting test cases left as a regression test for future maintenance. This isn&#x27;t the only oppertunity here- if the whole monitoring
algorithm is pure then it can be tested in the same way, leading to a larger percentage of easily testable code.&lt;&#x2F;p&gt;
&lt;p&gt;Consider what happens if these functions are not pure- what if you have to reconfigure the system between test cases, or if you can only test at a system level
because the code &lt;em&gt;requires&lt;&#x2F;em&gt; interaction with other modules to run? In my experience the unit testing is less rigorous, and the system level testing is very complex
and time consuming. There is no good way to do random testing, and its essentially impossible to test every function in isolation- the testing ends up being at a higher
level. &lt;&#x2F;p&gt;
&lt;p&gt;In other words, the core enabling aspect of the design that allows it to be testable is to ensure that as much as possible is written in a way that can be
reasoned about in isolation. Pure functions are the best way that I know to accomplish this.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;core-algorithm-case-1&quot;&gt;Core Algorithm - Case 1&lt;&#x2F;h1&gt;
&lt;p&gt;Another example I&#x27;ve seen is the core algorithms of a system. These algorithms may be defined by domain experts, and require validation effort to ensure that the
implementation matches the intention. These algorithms are a lot of work, and must be specified carefully and tested rigorously.&lt;&#x2F;p&gt;
&lt;p&gt;Even when these algorithms end up effecting the system&#x27;s state, it is worth while designing them to take in all of their required input (not relying on other state or
interaction with the rest of the system) and to produce a structure describing their result instead of acting on it while the algorithm runs.&lt;&#x2F;p&gt;
&lt;p&gt;I have seen situations where an algorithm is only partially pure- parts are factored out into pure functions and part is not. The parts that were pure were easier
to re-use as the project matured, while the parts that were not couldn&#x27;t be repurposed without a major rewrite late on in the project. Had the whole algorithm been
kept pure, it could have been run by request of the user and reported its results instead of acting on them. This would have given more insight into the system that
is not available if the algorithm has its actions built in.&lt;&#x2F;p&gt;
&lt;p&gt;This left the system less useable then it might have been. The system was a high assurance piece of software, and we couldn&#x27;t afford to re-write it,
so it was left as is.  This is where my mistake was only making part of the code pure. The C language does not help you write pure code, and it doesn&#x27;t make
factoring code out terribly easy as well with its limited abilities for abstraction, but its worth the effort if you can do it.&lt;&#x2F;p&gt;
&lt;p&gt;The lesson for me here was that keeping as much code pure as possible would have enabled it to be tested in isolation and reasoned about locally, allowing
it to be moved or re-used without having to ensure that it operated the same in the new configuration. That additional effort it a hidden cost to side-effecting
code that can make it completely unmaintainable in a large enough scale (I have seen this first hand as well).&lt;&#x2F;p&gt;
&lt;h1 id=&quot;core-algorithm-case-2&quot;&gt;Core Algorithm - Case 2&lt;&#x2F;h1&gt;
&lt;p&gt;Another example from that project was an algorithm that integrates an equation of motion for the vehicle it is on to predict its future positions. This algorithm was written
as a library with all pure functions from the beginning- I was not going to repeat my mistake from the previous example. &lt;&#x2F;p&gt;
&lt;p&gt;The result was something that could be tested as a whole and in parts in the units tests, both with fixed inputs and random inputs. It was ported to a laptop
visualization with nearly no effort to explore and understand the results it would give in different situations. All of this left me very confident in its
definition, and confident that it would continue to work in operation- no latent dependance on the system&#x27;s state is possible if you don&#x27;t depend on state
at all.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;serial-communications&quot;&gt;Serial Communications&lt;&#x2F;h1&gt;
&lt;p&gt;One last example is code that recieves data on a serial port (or over TCP) and validates it before sending it on. This kind of code can be implemented as a state machine
which transitions states as it receives different parts of a packet- first a sync word, then a header with a length, then the data, then a checksum or CRC.&lt;&#x2F;p&gt;
&lt;p&gt;This is an interesting example for several reasons- one is that it involves hardware, which one might think as difficult to handle with pure functions, and that it uses a 
state machine, meaning it relies on state. However, if the code to receive data is decoupled from this state machine then the state machine can be implemented as a pure function
that takes in the current state (and usually some description of the processing so far), and produces a new state and a new description.&lt;&#x2F;p&gt;
&lt;p&gt;This design, as in the above cases, allows a large portion of the code to be easily tested- all state transitions can be tested in different situations. Good data can be injected
during a test, such as from a file, and random data can be created to test edge cases.&lt;&#x2F;p&gt;
&lt;p&gt;Usually this kind of data is injected into the interface itself, which would work. However, if the system doesn&#x27;t work then you have to ask whether its the code or the interface.
If the code can be tested seperately you can have more confidence in it from the start, and you can add test cases to the code as you find them, rather then relying on someone
injecting all the test cases using a simulator every time they run the code.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h1&gt;
&lt;p&gt;This is just the tip of the iceburg on this subject in terms of the application so of purity in embedded systems, and in applying lessons from functional programming to
embedded systems programming. I&#x27;ve been looking at other examples on a new project where I&#x27;ve found that my designs differ depending on whether I&#x27;m wearing my
flight software systems hat or my functional programming hat, and the latter designs seem to have all the advantages I&#x27;ve described above.&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>Algebraic Data Types</title>
                <pubDate>Mon, 14 Nov 2016 00:00:00 +0000</pubDate>
                <link>https%3A//nsmryan.github.com/public/algebraic-data-types/</link>
                <guid>https%3A//nsmryan.github.com/public/algebraic-data-types/</guid>
                <description>&lt;p&gt;This post starts a description of algebraic data types. For me, these have completely replaced
my mental machinery for designing and reasoning about programs. They also provide a way to explore
ideas and guide my programs.&lt;&#x2F;p&gt;
&lt;p&gt;The types described here are monomorphic- they do not have any type parameters. The whole algebraic
structure can be lifted up a level to combine structures that have type parameters, which I hope to
get to in another post.
Hopefully I can get into even more fun through how this lifts into Functors, or to the Howard
Curry Isomorphism and how the type systems we look at are systems of logic.&lt;&#x2F;p&gt;
&lt;p&gt;My main exposure to functional programming languages is Haskell, and the Elm I&#x27;m been exploring recently.
The descriptions given here are a mix of Haskell, type theory, set theory, and natural language.&lt;&#x2F;p&gt;
&lt;p&gt;We will start our journey with the primitive types that make up the floor of the tower of types that
can be defined by taking the sums, products, and exponents of algebraic types. We will work our way
up to the operators themselves and the motivation for their names, as well as some uses for each.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;primitive-types&quot;&gt;Primitive Types&lt;&#x2F;h1&gt;
&lt;p&gt;A type system will have a series of primitive types for things like integers, positive numbers, encodings
of the reals, characters, and booleans.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;enumerations&quot;&gt;Enumerations&lt;&#x2F;h1&gt;
&lt;p&gt;They can also have a way to describe types with a finite number of elements, indexed by natural
numbers (enumerations). Enumerations end up being like having natural number in the type system, as we
will see later.&lt;&#x2F;p&gt;
&lt;p&gt;Enumerations provide some motivation for the name &amp;quot;algebraic&amp;quot; data types. They consist of a set of
symbols, often identified with a integer.&lt;&#x2F;p&gt;
&lt;p&gt;In C this would look like:
enum MSG_ID_ENUM;
{
MSG_ID_SAVE,
MSG_ID_UPDATE,
MSG_ID_PRINT
};&lt;&#x2F;p&gt;
&lt;p&gt;and in Haskell
data MsgId = MsgIdSave | MsgIdUpdate | MsgIdPrint deriving (Enum)&lt;&#x2F;p&gt;
&lt;p&gt;An enumeration has a finite number of elements, and acts as a natural number within the type system.
The number that an enumeration cooresponds to is the number of elements that it has.&lt;&#x2F;p&gt;
&lt;p&gt;We will see later that the sums, products, and exponents of algebraic data types act like sums, product,
and exponents on the number of elements in an enumeration.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;products&quot;&gt;Products&lt;&#x2F;h1&gt;
&lt;p&gt;Product types or something like them are common, and come up immediately when modeling essentially
any information. The values of this type are, for example &amp;quot;(3, &amp;quot;test&amp;quot;, True)&amp;quot;.
When reading this value, we have a 3, and the string &amp;quot;test&amp;quot;, and the boolean value True.
In C and its family of languages they are called structs.&lt;&#x2F;p&gt;
&lt;p&gt;In Haskell the product type is written &amp;quot;(a,b)&amp;quot;. Other product types can be defined, such as
&amp;quot;data Prod a b = Prod a b&amp;quot;, which are isomorphic to &amp;quot;(a,b)&amp;quot;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;algebra&quot;&gt;Algebra&lt;&#x2F;h2&gt;
&lt;p&gt;As an initial motivation for considering these types &amp;quot;products&amp;quot; rather than &amp;quot;sums&amp;quot; or something else is to
consider what happens when taking the product of enumerations- the number of elements in the product
of two enumerations is the product of the number of elements of each.&lt;&#x2F;p&gt;
&lt;p&gt;This isn&#x27;t the only reason that these are products. When we get to sum types, we will see that products
distribute over sums, just as they would in elementary algrebra.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;logic&quot;&gt;Logic&lt;&#x2F;h2&gt;
&lt;p&gt;Products sequence data- they are like the word (and logical connective) &amp;quot;and&amp;quot;.
The product of an integer, a string, and a boolean might be written &amp;quot;integer x string x boolean&amp;quot;
or &amp;quot;(integer, string, boolean)&amp;quot;.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;unit&quot;&gt;Unit&lt;&#x2F;h1&gt;
&lt;p&gt;Algebra
The unit of multiplication is 1, and the unit of the product of types is (), sometimes called Unit.
It is a type with a single inhabitant, in Haskell this element is also called (). &lt;&#x2F;p&gt;
&lt;p&gt;This is the unit of product types for the same reason that the cartesian product of a set with
a set containing one element is isomorphic to the original set- all elements are paired with the
same value so it adds nothing to the structure. In symbols ax() ~ a.&lt;&#x2F;p&gt;
&lt;p&gt;A fun fact about the unit type is that the type of functions from unit into a type &#x27;a&#x27; is isomorphic to
a- in symbols this is the fact that () -&amp;gt; a ~ a. This is because each function can map the () into a
single element. Going the other way, each function can be mapped to an element of the type &#x27;a&#x27; by
simply applying the function to the () value.&lt;&#x2F;p&gt;
&lt;p&gt;This ignores some details about extra bottom elements having to do with non-terminating computations.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;logic-1&quot;&gt;Logic&lt;&#x2F;h2&gt;
&lt;p&gt;Product types coorespond to the And connective in logic. The unit of And is True- &#x27;True And p&#x27; has the
proof value of p, the same as &#x27;p And True&#x27;. &lt;&#x2F;p&gt;
&lt;h1 id=&quot;sums&quot;&gt;Sums&lt;&#x2F;h1&gt;
&lt;p&gt;Sum types are more rare in programming languages then product types, but they are hugely useful.
When designing a game, or the communication of two systems, or the telemetry reported by
an embedded system, one often needs to provide one of several possible options perhaps
with additional data. &lt;&#x2F;p&gt;
&lt;p&gt;In C, one might right:
typedef union
{
SaveData saveData;
UpdateData updateData;
PrintData printData;
} Payload;&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#212733;&quot;&gt;
&lt;span style=&quot;color:#ccc9c2;&quot;&gt;enum MSG_ID_ENUM;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ccc9c2;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ccc9c2;&quot;&gt;  MSG_ID_SAVE,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ccc9c2;&quot;&gt;  MSG_ID_UPDATE,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ccc9c2;&quot;&gt;  MSG_ID_PRINT
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ccc9c2;&quot;&gt;};

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ccc9c2;&quot;&gt;typedef struct
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ccc9c2;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ccc9c2;&quot;&gt;  MSG_ID_ENUM msgID;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ccc9c2;&quot;&gt;  Payload payload;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ccc9c2;&quot;&gt;} Message;
&lt;&#x2F;span&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The enumeration is required to distinguish between the possible values for the message payload.
The union type itself is like a union in set theory- the number of elements in a union type is the number
of elements in each of the two types, minus the shared elements. Sum types are more like a disjoint union-
the tag prevents elements that would otherwise be the same from being equal. The whole concept of
elements of sets being equal is a little tricky due to the lack of unions and the complexity of equality
in type theory. Just note that there is some subtly here.&lt;&#x2F;p&gt;
&lt;p&gt;In Haskell this might look like:
data Payload = PayloadSave SaveData
| PayloadUpdate UpdateData
| PayloadPrint PrintData&lt;&#x2F;p&gt;
&lt;p&gt;Depending on the situation, the data within the SaveData, UpdateData, and PrintData types can
be placed within the PayloadSave, PayloadUpdate, and PayloadPrint constructors. The equalivant in C
would be to use anonymous structs.&lt;&#x2F;p&gt;
&lt;p&gt;The values of this type can contain any of the three constructors. This allows multiple types of messages
to be sent and received in a type same way. &lt;&#x2F;p&gt;
&lt;p&gt;If there are only two types to sum, we could use:
type Payload = Either SaveData UpdateData
but this gets cumbersome with more types:
type Payload = Either SaveData (Either UpdateData PrintData)&lt;&#x2F;p&gt;
&lt;h2 id=&quot;algebra-1&quot;&gt;Algebra&lt;&#x2F;h2&gt;
&lt;p&gt;Now that we have products and sums, we can see how they interact. In Haskell:
type T1 = (a, Either b c)
is isomorphic to:
type T2 = (Either a b, Either a c)
Both types must have a value of type &#x27;a&#x27;, and both will have either a value of type &#x27;b&#x27; or &#x27;c&#x27;.
Their values are different, but there is a function from T1 to T2 and back which compose in both
directions to produce the identity function.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;logic-2&quot;&gt;Logic&lt;&#x2F;h2&gt;
&lt;p&gt;The connection between algebra and logic for sums is that sum types are like the word (and logical
connective). Given a type &amp;quot;integer + boolean&amp;quot;, written in Haskell as &amp;quot;Either Int Bool&amp;quot;,
its values are &amp;quot;Left 3&amp;quot; or &amp;quot;Right True&amp;quot;.&lt;&#x2F;p&gt;
&lt;p&gt;The introduction form for an Or operator requires either a value of type &#x27;a&#x27; or a value of type &#x27;b&#x27;.
If &#x27;a&#x27; is true, then we can make the statment &#x27;a Or b&#x27;, and if &#x27;b is true, we can still make the
statement &#x27;a Or b&#x27;. I&#x27;m ignoring the difference between a true statement in classical logic,
and a proof of a type by an element of it.&lt;&#x2F;p&gt;
&lt;p&gt;The elimination form for Or requires a way to prove a statement&#x2F;type &#x27;c&#x27; using an &#x27;a&#x27;, or a way to
prove a type &#x27;c&#x27; using a &#x27;b&#x27;. In symbols, &#x27;(a -&amp;gt; c) -&amp;gt; (b -&amp;gt; c) -&amp;gt; (a Or b) -&amp;gt; c&#x27;. The statement
&#x27;c&#x27; is true if &#x27;a Or b&#x27; is true and there is a way to prove c regardless of which of &#x27;a&#x27; or &#x27;b&#x27; is
true.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;void&quot;&gt;Void&lt;&#x2F;h1&gt;
&lt;p&gt;The unit of addition is 0, and the unit of sum types is Void. This type has no values (ignoring bottom
if it exists, as usual).&lt;&#x2F;p&gt;
&lt;p&gt;This is why it is the unit of sum types- it is a path that cannot be taken.
Taking the sum with the Void type means that one side of the sum has no values, so it is like tagging
all values of the other type with the same tag. This doesn&#x27;t change the structure of the type in
any meaningful way.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;logic-3&quot;&gt;Logic&lt;&#x2F;h2&gt;
&lt;p&gt;Sums coorespond to the Or connective in logic. The unit of Or is False, as &#x27;False Or p&#x27; has the truth
value of p, which is the same as &#x27;p Or False&#x27;. This is appropriate, as there should be no way to 
construct a valid proof which is false in a system of logic. The connection to constructive logic
here makes the connection even more interesting- this is no surprise as the type theory of a language
is a system of logic.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;exponents&quot;&gt;Exponents&lt;&#x2F;h1&gt;
&lt;p&gt;Exponential types also come up all the time, and the presence or absense of these are, for me,
one of the biggest distinguishing factors between programming languages. &lt;&#x2F;p&gt;
&lt;p&gt;Suprisingly, exponentials coorespond to function types such as &amp;quot;a -&amp;gt; b&amp;quot;, pronouced &amp;quot;a arrow b&amp;quot;. This is
the type of functions from a type &#x27;a&#x27; to a type &#x27;b&#x27;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;algebra-2&quot;&gt;Algebra&lt;&#x2F;h2&gt;
&lt;p&gt;To continue the motivation with enumerations: the space of functions from an enumeration with n elements
to an enumeration with m elements has m^n elements (m raised to the n). This is because each function
must map each element of the first enumeration to an element of the second. This means each function
makes n choices, each of which can be from one of m values.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;logic-4&quot;&gt;Logic&lt;&#x2F;h2&gt;
&lt;p&gt;The cooresponding operator in logic is implication. The introduction and elimination forms in lambda
calculus describe how to use this operator.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;haskell&quot;&gt;Haskell&lt;&#x2F;h2&gt;
&lt;p&gt;I can&#x27;t help but mention how well functions and function types are supported in Haskell. They are
available in other languages, but not in the same way. Haskells functions are a powerful tool,
a way to abstract and combine computations.&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>Functional Programming Conference Videos</title>
                <pubDate>Tue, 25 Oct 2016 00:00:00 +0000</pubDate>
                <link>https%3A//nsmryan.github.com/public/functional-programming-conference-videos/</link>
                <guid>https%3A//nsmryan.github.com/public/functional-programming-conference-videos/</guid>
                <description>&lt;p&gt;This post just lists some links to videos with Haskell content.
Some of the best presenters are Conal Elliot, Gabriel Gonzalez and Edward Kmett.
There are a lot of good videos in this list. Its worth looking through them if you
are interested in Haskell and Functional Programming.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;icfp&quot;&gt;ICFP&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;channel&#x2F;UCwRL68qZFfub1Ep1EScfmBw&#x2F;videos&quot;&gt;https:&#x2F;&#x2F;www.youtube.com&#x2F;channel&#x2F;UCwRL68qZFfub1Ep1EScfmBw&#x2F;videos&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h1 id=&quot;icfp-2012-and-2014&quot;&gt;ICFP 2012 and 2014&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;channel&#x2F;UCP9g4dLR7xt6KzCYntNqYcw&#x2F;videos&quot;&gt;https:&#x2F;&#x2F;www.youtube.com&#x2F;channel&#x2F;UCP9g4dLR7xt6KzCYntNqYcw&#x2F;videos&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h1 id=&quot;compose-conference&quot;&gt;Compose Conference&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;channel&#x2F;UC0pEknZxL7Q1j0Ok8qImWdQ&#x2F;videos&quot;&gt;https:&#x2F;&#x2F;www.youtube.com&#x2F;channel&#x2F;UC0pEknZxL7Q1j0Ok8qImWdQ&#x2F;videos&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h1 id=&quot;fp-syd&quot;&gt;FP Syd&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;channel&#x2F;UCm1omK1YKzCzCV2yemL_NpA&#x2F;videos?shelf_id=0&amp;amp;view=0&amp;amp;sort=dd&quot;&gt;https:&#x2F;&#x2F;www.youtube.com&#x2F;channel&#x2F;UCm1omK1YKzCzCV2yemL_NpA&#x2F;videos?shelf_id=0&amp;amp;view=0&amp;amp;sort=dd&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h1 id=&quot;haskell-to-hardware&quot;&gt;Haskell to Hardware&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;vimeo.com&#x2F;125504650&quot;&gt;https:&#x2F;&#x2F;vimeo.com&#x2F;125504650&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h1 id=&quot;new-york-haskell&quot;&gt;New York Haskell&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;channel&#x2F;UCzNYHE7Kj6pBqq5h8LG9Zcg&#x2F;videos&quot;&gt;https:&#x2F;&#x2F;www.youtube.com&#x2F;channel&#x2F;UCzNYHE7Kj6pBqq5h8LG9Zcg&#x2F;videos&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h1 id=&quot;yow-australia&quot;&gt;YOW! Australia&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;user&#x2F;YOWAustralia&#x2F;videos&quot;&gt;https:&#x2F;&#x2F;www.youtube.com&#x2F;user&#x2F;YOWAustralia&#x2F;videos&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h1 id=&quot;google-tech-talks&quot;&gt;Google Tech Talks&lt;&#x2F;h1&gt;
&lt;p&gt;Some of the Haskell videos come from ZuriHac&lt;&#x2F;p&gt;
&lt;h1 id=&quot;monadic-warsaw&quot;&gt;Monadic Warsaw&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;channel&#x2F;UCCeiYYR2fCXarkfSqqFBwuA&quot;&gt;https:&#x2F;&#x2F;www.youtube.com&#x2F;channel&#x2F;UCCeiYYR2fCXarkfSqqFBwuA&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h1 id=&quot;boston-haskell&quot;&gt;Boston Haskell&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;channel&#x2F;UCUCpgCWjaniUkX88wZrK_Ig&#x2F;videos&quot;&gt;https:&#x2F;&#x2F;www.youtube.com&#x2F;channel&#x2F;UCUCpgCWjaniUkX88wZrK_Ig&#x2F;videos&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h1 id=&quot;begriffs-videos&quot;&gt;Begriffs Videos:&lt;&#x2F;h1&gt;
&lt;p&gt;Just some of my favorite from begriffs
&lt;a href=&quot;https:&#x2F;&#x2F;begriffs.com&#x2F;posts&#x2F;2015-06-28-haskell-to-hardware.html&quot;&gt;https:&#x2F;&#x2F;begriffs.com&#x2F;posts&#x2F;2015-06-28-haskell-to-hardware.html&lt;&#x2F;a&gt;
&lt;a href=&quot;https:&#x2F;&#x2F;begriffs.com&#x2F;posts&#x2F;2016-06-27-fast-haskell-regexes.html&quot;&gt;https:&#x2F;&#x2F;begriffs.com&#x2F;posts&#x2F;2016-06-27-fast-haskell-regexes.html&lt;&#x2F;a&gt;
&lt;a href=&quot;https:&#x2F;&#x2F;begriffs.com&#x2F;posts&#x2F;2015-12-14-fft-with-circat.html&quot;&gt;https:&#x2F;&#x2F;begriffs.com&#x2F;posts&#x2F;2015-12-14-fft-with-circat.html&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>Fifth Elm Project- Cursor Trail</title>
                <pubDate>Mon, 17 Oct 2016 00:00:00 +0000</pubDate>
                <link>https%3A//nsmryan.github.com/public/fifth-elm-project-cursortrail/</link>
                <guid>https%3A//nsmryan.github.com/public/fifth-elm-project-cursortrail/</guid>
                <description>&lt;p&gt;This time I wanted to do something with the mouse cursor. This little program just draws a trail
after the mouse cursor as you move it.&lt;&#x2F;p&gt;
&lt;p&gt;You can play with it  &lt;a href=&quot;http:&#x2F;&#x2F;itscomputersciencetime.com&#x2F;elm&#x2F;cursortrail.html&quot;&gt;here&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The code is on my github repository in the Elm directory as
&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;nsmryan&#x2F;itscomputersciencetime.com&#x2F;blob&#x2F;master&#x2F;elm&#x2F;cursortrail.elm&quot;&gt;cursortrail.elm&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>Fourth Elm Project- Quad</title>
                <pubDate>Sun, 16 Oct 2016 00:00:00 +0000</pubDate>
                <link>https%3A//nsmryan.github.com/public/fourth-elm-project-quad/</link>
                <guid>https%3A//nsmryan.github.com/public/fourth-elm-project-quad/</guid>
                <description>&lt;p&gt;Yet another little Elm experiment!&lt;&#x2F;p&gt;
&lt;p&gt;This time I wanted to visualize quad trees. By far the hardest part of this whole experience
was figuring out how to draw them. The mouse positions are received with the positive y direction
going downwards from the top of the screen, the Graphics.Collage routines expect x and y
to be centered in the middle of the screen (with y positive going up), and I structured the
trees to expect the origin to be the bottom left (y positive going up)!&lt;&#x2F;p&gt;
&lt;p&gt;You can play with it  &lt;a href=&quot;http:&#x2F;&#x2F;itscomputersciencetime.com&#x2F;elm&#x2F;quad.html&quot;&gt;here&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The code is on my github repository in the Elm directory as
&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;nsmryan&#x2F;itscomputersciencetime.com&#x2F;blob&#x2F;master&#x2F;elm&#x2F;quad.elm&quot;&gt;quad.elm&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>Third Elm Project-Split</title>
                <pubDate>Sun, 16 Oct 2016 00:00:00 +0000</pubDate>
                <link>https%3A//nsmryan.github.com/public/third-elm-project-split/</link>
                <guid>https%3A//nsmryan.github.com/public/third-elm-project-split/</guid>
                <description>&lt;p&gt;A third elm program!&lt;&#x2F;p&gt;
&lt;p&gt;Try pressing any key to split the line as it grows.&lt;&#x2F;p&gt;
&lt;p&gt;The program is &lt;a href=&quot;http:&#x2F;&#x2F;itscomputersciencetime.com&#x2F;elm&#x2F;split.html&quot;&gt;here&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The code is on my github repository in the Elm directory as
&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;nsmryan&#x2F;itscomputersciencetime.com&#x2F;blob&#x2F;master&#x2F;elm&#x2F;split.elm&quot;&gt;split.elm&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Have fun.&lt;&#x2F;p&gt;
</description>
            </item>
        
    </channel>
</rss>
