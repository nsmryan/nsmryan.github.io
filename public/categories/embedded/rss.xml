<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>itscomputersciencetime</title>
        <link>http%3A//itscomputersciencetime.com/public</link>
        <description></description>
        <generator>Zola</generator>
        <language>en</language>
        <atom:link href="http%3A//itscomputersciencetime.com/public/categories/embedded/rss.xml" rel="self" type="application/rss+xml"/>
        <lastBuildDate>Sat, 23 Feb 2019 00:00:00 +0000</lastBuildDate>
        
            <item>
                <title>Decoding with Session Types</title>
                <pubDate>Sat, 23 Feb 2019 00:00:00 +0000</pubDate>
                <link>http%3A//itscomputersciencetime.com/public/decoding-with-session-types/</link>
                <guid>http%3A//itscomputersciencetime.com/public/decoding-with-session-types/</guid>
                <description>&lt;p&gt;This post is a thought I had a while back about data decoding, but which I will likely not pursue. I just wanted to 
record it somewhere in the open. I&#x27;m no expert in type theory, so the concept of session types might be 1) wrong, 
or 2) trivial, but might none-the-less be interesting.&lt;&#x2F;p&gt;
&lt;p&gt;The idea is around decoding data, especially binary formats. I deal with a lot of different binary formats of varying
complexity, and they generally fall within a certain set of features:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Structures containing a series of named fields&lt;&#x2F;li&gt;
&lt;li&gt;Subcom data (sum types) whose intrepretation is indicated by some other field within the packet&lt;&#x2F;li&gt;
&lt;li&gt;Primitive types- signed and unsigned integers, single and double precision floating point numbers, sometimes
buffers or fixed or variable length, and sometimes buffers terminated by a particular symbol like a NULL terminated
string. Some systems will use bit fields, and some will have exotic encodings like 48 bit floats.&lt;&#x2F;li&gt;
&lt;li&gt;Data integrity checks like a CRC or checksum. These must be computed from the data, and may require custom code (its
hard to cover all possible cases).&lt;&#x2F;li&gt;
&lt;li&gt;Overlayed data, where the same data have multiple intepretations.&lt;&#x2F;li&gt;
&lt;li&gt;Calculated data, sometimes called a derived parameter, which must be computed from one or more parameters and is not
an explicit field of the binary data.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;I attempted to come up with some algebraic structure for these things, where structures are a kind of multiplication (sequecing),
subcomming and overlayed data are kinds of sums, primitives are the primitives of the algebra. Fixed size buffers are multiples
of a primitive, while variable length buffers are perhaps a certain kind of infinite sum or something.&lt;&#x2F;p&gt;
&lt;p&gt;What this lead me to was this view of decoding data as an interaction between the decoding program and the binary data.
The idea is that decoding a primitive is like requesting a value of a particular type. Then decoding a structure
is like requesting several types of data in turn, and decoding an overlay of data is like requesting two types at once.&lt;&#x2F;p&gt;
&lt;p&gt;The more interesting case is subcommed types. In this case, the decoder provides several possible response to the binary
data, which can respond with the one that corresponds to the current packet. In other words, instead of telling the packet
what data we want next, we ask it which type of data it wants to provide. This seems very much like the connectors
of a system of session types.&lt;&#x2F;p&gt;
&lt;p&gt;Calculated data can simply be done on the decoder&#x27;s side- I don&#x27;t think it needs to be part of the decoding process.&lt;&#x2F;p&gt;
&lt;p&gt;Thats all there is to this idea- its just a recognition of a similarity between how session types can request a value,
or provide a choice, to someone, and how that matches with decoding binary data where we sometimes know what we want next
and sometimes we depend on the data to tell use what happens next.&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>Generic C</title>
                <pubDate>Tue, 13 Feb 2018 00:00:00 +0000</pubDate>
                <link>http%3A//itscomputersciencetime.com/public/generic-c/</link>
                <guid>http%3A//itscomputersciencetime.com/public/generic-c/</guid>
                <description>&lt;p&gt;This post is about how to write generic code in C. This is a problem I often have- I write tools in C which are fairly
simple, but often would benefit from more advanced techniques as they get larger. I use C because it is the language we use for flight code,
it is a simple language that I can expect people to know, and it is easier to control the layout of memory then other languages.
I can write a useful GUI program in LabWindows in hours, talk to hardware, and process telemetry from other systems. Its by no means
my favorite language, but its often the right tool for the work that I do.&lt;&#x2F;p&gt;
&lt;p&gt;This is a language that does not include a lot of means for abstraction, and we will have to pull some tricks to reduce redundancy
and express more complex concepts. These things do not feel native to the language, and I feel like I am usually using a fairly
primitive set of building blocks to create my programs.
The techniques we will look at are manual and its easier to get wrong in C then other languages, but still worth thinking about.&lt;&#x2F;p&gt;
&lt;p&gt;So- lets look at what we can do to get some polymorphism in C when we are not ready or able to reach for other languages.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;some-context&quot;&gt;Some Context&lt;&#x2F;h1&gt;
&lt;p&gt;The C language is fairly low level and explict. Sometimes it is not low level enough, and often it is much too low level.
In flight code (any code that runs on the embedded systems for space or aero applications) we keep a small subset of C and stray very little
into more advanced techniques in order to keep the code as understandable as possible. For me then, these techniques are things I would
use when no one is looking too closely at my code, or I&#x27;m writing something for myself.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-c-language&quot;&gt;The C Language&lt;&#x2F;h2&gt;
&lt;p&gt;The main constructions in C are procedures, structs, unions, enums, global values, and 
proprocessor directives. I&#x27;m grouping the preprocessor into C as they are part of C programs in practice,
even if they are a separate stage of compilation before the C language itself. C&#x27;s type system
has primitive types (int, char, etc), the array type constructor, user types in the form
of structs and unions, type alias in typedefs, and pointer types.&lt;&#x2F;p&gt;
&lt;p&gt;Of these, pointer types give the most means for abstraction- they let you talk about data in an uniform way (through an address) that does not
depend on the structure of the data, as the pointer is always the same form regardless of what it points to.
In addition, function pointers get you the bare minimum to treat computation as a subject that one can control in
C. There is no way to create functions at run time such as through composition, but at least we have first order functions.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;the-cast&quot;&gt;The Cast&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;pre-processor-magic&quot;&gt;Pre-Processor Magic&lt;&#x2F;h2&gt;
&lt;p&gt;One way to get a form of polymorphism in your code is to essentially expand it automatically to monomorphic code-
in other words, create an entirely separate copy for each type you are interested in manipulating. This can be
done with the preprocessor, allowing entire data structures and their interfaces to be generated per type.
This reminds me in logic of expanding your inference rules so that there is technically a separate rule for each
proposition, rather then using quantification and saying that the rules apply for all propositions.&lt;&#x2F;p&gt;
&lt;p&gt;This has the advantage of type safety, since the code is generated for a particular type, and it may have some
performance advantages when the implementation can make use of properties of the type like its size to generate
specific code like memory layouts.&lt;&#x2F;p&gt;
&lt;p&gt;One disadvantage is complexity- both in the implementation which must be written mostly within the pre-processor,
and in the user code which must generate a great deal of code that can&#x27;t be read directly. Even reading the generated
code is not as good as having simple code to read in the first place. I imagine this code is hard to write and test,
although I&#x27;ve never done it myself.&lt;&#x2F;p&gt;
&lt;p&gt;An example of this approach is in &lt;a href=&quot;http:&#x2F;&#x2F;sglib.sourceforge.net&#x2F;doc&#x2F;index.html&quot;&gt;sglib&lt;&#x2F;a&gt; where the author create type safe
data structures and some higher order functionality like sorting with user-defined functions, in C.&lt;&#x2F;p&gt;
&lt;p&gt;One other note here is that I&#x27;ve seen this technique done manually as well- duplicate data structures and functions with
almost no difference all through codebases. This is bad programming practice and is wasteful in time for programming, testing,
and reviewing, but in some contexts its hard to avoid.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;void&quot;&gt;void * &lt;&#x2F;h2&gt;
&lt;p&gt;Another possibility is to simply drop into the world of untyped data, making everything a pointer to void. This means
that you take responsibility for the types of your data. You can do this by always using void pointers to a particular type
with a section of code, such as in a data structure like a tree where all nodes point to data of the same type, or you can
do a manual kind of sum type and make an enum with all the types you want to use, tagging your pointers with a value of this enum
to distinguish what it points to. This amounts to carving out a universe of types from the C type system, and when I&#x27;ve done this usually
I only allow basic types like uint8, int16, uint32, etc, and then a generic buffer or C string type.&lt;&#x2F;p&gt;
&lt;p&gt;The advantage of this techinque is that your code works on many data types- you can store information like the size of the data along with it,
and allocate, deallocate, move, and manipulate your data without knowing what it is. This is almost a parametric polymorphism in the sense that if you
truely do not know what your data contains, so you can only perform operations on it that work on all data. Nothing stops you from doing otherwise,
but we are in C and we have to accept this responsibility.&lt;&#x2F;p&gt;
&lt;p&gt;This is the technique I go for most often. I don&#x27;t enjoy it, but it comes in useful too often to ignore.&lt;&#x2F;p&gt;
&lt;p&gt;I know of no way to enforce constraints in this case, unless you consider the next technique a kind of constraint.&lt;&#x2F;p&gt;
&lt;p&gt;One example of this style can be found &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;srdja&#x2F;Collections-C&quot;&gt;here&lt;&#x2F;a&gt;. This is also the style used in LabWindows for its
generic data structures in the &lt;a href=&quot;http:&#x2F;&#x2F;zone.ni.com&#x2F;reference&#x2F;en-XX&#x2F;help&#x2F;370051V-01&#x2F;toolslib&#x2F;toolslibprogrammerstoolbox_functiontree&#x2F;&quot;&gt;programmer&#x27;s toolbox&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;row-polymorphism&quot;&gt;Row Polymorphism&lt;&#x2F;h2&gt;
&lt;p&gt;This is perhaps the most interesting technique, at least to me. In this case you define a series of structures, some of which contain others as their
first field. Doing this means that you can upcast a struct into one of the ones it contains, losing information about what it contains. This gives it a
similar feel to subtyping (although this does not hold up formally), where you can go own the tree of subtypes and get more information, and up the tree
to lose information when you want to express something more generically.&lt;&#x2F;p&gt;
&lt;p&gt;I&#x27;ve wanted to explore this in more detail, as it opens up a lot of possibiilty in the restricted world of C. You do have to be careful with memory layout-
you can no longer assume you know the size of a structure based on its type. You are also restricted in the sense that you can extend in only one way per
struct- you can extend with new fields, but the order of extensions matters without some kind of dictionary or table lookup.&lt;&#x2F;p&gt;
&lt;p&gt;One example of this technique is the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;torvalds&#x2F;linux&quot;&gt;Linux kernel&lt;&#x2F;a&gt;. Linux apparently uses this technique to embed structs in other struct,
along with macros for getting out to the containing structure.&lt;&#x2F;p&gt;
&lt;p&gt;Another example might be &lt;a href=&quot;http:&#x2F;&#x2F;libcello.org&#x2F;home&quot;&gt;Cello&lt;&#x2F;a&gt;, which is a very different implementation then the one used in Linux, and does use a lookup
to dispatch functions. I hope to write a bit more about this in the future, but its definitely worth checking out, even if only for fun.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;generic&quot;&gt;_Generic&lt;&#x2F;h2&gt;
&lt;p&gt;In C11 there was a feature added to the C language called _Generic. This is not a general technique for generic programming- all it allows you to do
is to select a function based on a type. You can then write macros that select the right function but give a single interface which is nice, but to my knowledge
there is no way to use this more generally- you have to know beforehand which types you are concerned with. Its still a fine feature, its just got a more limited
application then the techniques above.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h1&gt;
&lt;p&gt;I tend to stick to void* style generic programming in C because it is the most straightforward in my opinion and the easiest to review for. I&#x27;m more interested
in sticking to conventions and keeping code simple then powerful and generic. I am even willing to trade the type safety of macros for code that uses the simplest
subset of C possible, but that is mostly my training and my application domain talking. I treat C more carefully than other languages because my C code must be
higher quality then my other code.&lt;&#x2F;p&gt;
&lt;p&gt;Also,for reference, &lt;a href=&quot;http:&#x2F;&#x2F;andreinc.net&#x2F;2010&#x2F;09&#x2F;30&#x2F;generic-data-structures-in-c&#x2F;&quot;&gt;here&lt;&#x2F;a&gt; is another treatment of these same topics.&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>SAGE III Launch</title>
                <pubDate>Thu, 23 Feb 2017 00:00:00 +0000</pubDate>
                <link>http%3A//itscomputersciencetime.com/public/sageiii-launch/</link>
                <guid>http%3A//itscomputersciencetime.com/public/sageiii-launch/</guid>
                <description>&lt;p&gt;The SAGE III payload launched on SpaceX CRS-10 last weekend. I worked on the software for the flight computer for this payload, the IAM, and I got to see the launch.o&lt;&#x2F;p&gt;
&lt;p&gt;Check out the technical webcast from SpaceX (https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=rUDLxFUMC9c) at 25:03.
You can see the SAGE III Payload inside the Dragon trunk, along with the NVP that the payload mounts to. Its really incredible to see.&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>Pure Functions in Embedded Systems Programming</title>
                <pubDate>Wed, 25 Jan 2017 00:00:00 +0000</pubDate>
                <link>http%3A//itscomputersciencetime.com/public/pure-functions-in-embedded-systems-programming/</link>
                <guid>http%3A//itscomputersciencetime.com/public/pure-functions-in-embedded-systems-programming/</guid>
                <description>&lt;p&gt;I&#x27;ve had some experiences recently where I&#x27;ve seen code written in C&#x2F;C++ for embedded systems
that benefited from my experiences with Haskell. In short, I&#x27;ve found that pure functions make code more robust, easier to test,
easier to document, easier to reason about, and easier to extend to new situations (porting between systems, and wrapping in simulators&#x2F;ground systems)
and changing requirements.  The only thing I&#x27;ve regretted using this technique is that I don&#x27;t do enough of it.&lt;&#x2F;p&gt;
&lt;p&gt;This post describes some of my experiences factoring out portions of
my code into pure functions on Class B and Class B Safety Critical software. There are other applications of functional programming and type theory
to embedded systems programming, but this is a big one.&lt;&#x2F;p&gt;
&lt;p&gt;Some examples from my experience are fault detection systems (Fault Detection, Isolation, and Recovery or FDIR), core algorithms like
orbit propagation (as well as boundary determination in a geofencing system, predicting vehicle dynamics and other such algorithms), input
accepting systems for communication like state machines, validation functions for data, converting data (including packetizing it, converting
between time formats, and parsing configuation), and applying filters to data or packets. Some of these applications are described in more detail below.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;pure-functions&quot;&gt;Pure Functions&lt;&#x2F;h1&gt;
&lt;p&gt;Briely, a pure function should will always produce the same result for the same input, regardless of when or how many times it is run.
This prevents IO, global state, network traffic etc- anything that might modify how a function runs or make it non-deterministic.
This is a situation where restricting what you make use of is a hugely powerful technique, and having the discipline to
enfore purity (even in a language which does nothing to help you do that) yields huge benefits that pay for the time invested many times over.&lt;&#x2F;p&gt;
&lt;p&gt;In embedded systems, software is written as a series of modules, each with a particular task or roles within the system. Look at
Core Flight Software (CFS) for an example of this kind of architecture. Within this architecture, there tend to be several types of modules. Some examples are
modules that that perform software tasks (ie routing messages, packaging data, monitoring telemetry), modules that provide utility functions,
modules that run a particular algorithm, and modules that interface with hardware.&lt;&#x2F;p&gt;
&lt;p&gt;All of these modules can benefit from pure functions. Code that does not need to interface with hardware (utilities and algorithms) is especially good for this
kind of design, but even modules that interface with hardware can section off parts of their processing into pure functions and get the benefits.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;fdir&quot;&gt;FDIR&lt;&#x2F;h1&gt;
&lt;p&gt;A concrete example is a fault detection system that takes a series of structures defining what to monitor, and recieves a packet to inspect at a given rate.
This kind of system benefits from factoring all the monitoring code out into pure functions which apply single monitors. With that design, test cases can produce
a variety of things to monitor throughout a packet, and feed both the packet and what to look for within that packet, into a single function. The result can be
automatically inspected, and the resulting test cases left as a regression test for future maintenance. This isn&#x27;t the only oppertunity here- if the whole monitoring
algorithm is pure then it can be tested in the same way, leading to a larger percentage of easily testable code.&lt;&#x2F;p&gt;
&lt;p&gt;Consider what happens if these functions are not pure- what if you have to reconfigure the system between test cases, or if you can only test at a system level
because the code &lt;em&gt;requires&lt;&#x2F;em&gt; interaction with other modules to run? In my experience the unit testing is less rigorous, and the system level testing is very complex
and time consuming. There is no good way to do random testing, and its essentially impossible to test every function in isolation- the testing ends up being at a higher
level. &lt;&#x2F;p&gt;
&lt;p&gt;In other words, the core enabling aspect of the design that allows it to be testable is to ensure that as much as possible is written in a way that can be
reasoned about in isolation. Pure functions are the best way that I know to accomplish this.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;core-algorithm-case-1&quot;&gt;Core Algorithm - Case 1&lt;&#x2F;h1&gt;
&lt;p&gt;Another example I&#x27;ve seen is the core algorithms of a system. These algorithms may be defined by domain experts, and require validation effort to ensure that the
implementation matches the intention. These algorithms are a lot of work, and must be specified carefully and tested rigorously.&lt;&#x2F;p&gt;
&lt;p&gt;Even when these algorithms end up effecting the system&#x27;s state, it is worth while designing them to take in all of their required input (not relying on other state or
interaction with the rest of the system) and to produce a structure describing their result instead of acting on it while the algorithm runs.&lt;&#x2F;p&gt;
&lt;p&gt;I have seen situations where an algorithm is only partially pure- parts are factored out into pure functions and part is not. The parts that were pure were easier
to re-use as the project matured, while the parts that were not couldn&#x27;t be repurposed without a major rewrite late on in the project. Had the whole algorithm been
kept pure, it could have been run by request of the user and reported its results instead of acting on them. This would have given more insight into the system that
is not available if the algorithm has its actions built in.&lt;&#x2F;p&gt;
&lt;p&gt;This left the system less useable then it might have been. The system was a high assurance piece of software, and we couldn&#x27;t afford to re-write it,
so it was left as is.  This is where my mistake was only making part of the code pure. The C language does not help you write pure code, and it doesn&#x27;t make
factoring code out terribly easy as well with its limited abilities for abstraction, but its worth the effort if you can do it.&lt;&#x2F;p&gt;
&lt;p&gt;The lesson for me here was that keeping as much code pure as possible would have enabled it to be tested in isolation and reasoned about locally, allowing
it to be moved or re-used without having to ensure that it operated the same in the new configuration. That additional effort it a hidden cost to side-effecting
code that can make it completely unmaintainable in a large enough scale (I have seen this first hand as well).&lt;&#x2F;p&gt;
&lt;h1 id=&quot;core-algorithm-case-2&quot;&gt;Core Algorithm - Case 2&lt;&#x2F;h1&gt;
&lt;p&gt;Another example from that project was an algorithm that integrates an equation of motion for the vehicle it is on to predict its future positions. This algorithm was written
as a library with all pure functions from the beginning- I was not going to repeat my mistake from the previous example. &lt;&#x2F;p&gt;
&lt;p&gt;The result was something that could be tested as a whole and in parts in the units tests, both with fixed inputs and random inputs. It was ported to a laptop
visualization with nearly no effort to explore and understand the results it would give in different situations. All of this left me very confident in its
definition, and confident that it would continue to work in operation- no latent dependance on the system&#x27;s state is possible if you don&#x27;t depend on state
at all.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;serial-communications&quot;&gt;Serial Communications&lt;&#x2F;h1&gt;
&lt;p&gt;One last example is code that recieves data on a serial port (or over TCP) and validates it before sending it on. This kind of code can be implemented as a state machine
which transitions states as it receives different parts of a packet- first a sync word, then a header with a length, then the data, then a checksum or CRC.&lt;&#x2F;p&gt;
&lt;p&gt;This is an interesting example for several reasons- one is that it involves hardware, which one might think as difficult to handle with pure functions, and that it uses a 
state machine, meaning it relies on state. However, if the code to receive data is decoupled from this state machine then the state machine can be implemented as a pure function
that takes in the current state (and usually some description of the processing so far), and produces a new state and a new description.&lt;&#x2F;p&gt;
&lt;p&gt;This design, as in the above cases, allows a large portion of the code to be easily tested- all state transitions can be tested in different situations. Good data can be injected
during a test, such as from a file, and random data can be created to test edge cases.&lt;&#x2F;p&gt;
&lt;p&gt;Usually this kind of data is injected into the interface itself, which would work. However, if the system doesn&#x27;t work then you have to ask whether its the code or the interface.
If the code can be tested seperately you can have more confidence in it from the start, and you can add test cases to the code as you find them, rather then relying on someone
injecting all the test cases using a simulator every time they run the code.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h1&gt;
&lt;p&gt;This is just the tip of the iceburg on this subject in terms of the application so of purity in embedded systems, and in applying lessons from functional programming to
embedded systems programming. I&#x27;ve been looking at other examples on a new project where I&#x27;ve found that my designs differ depending on whether I&#x27;m wearing my
flight software systems hat or my functional programming hat, and the latter designs seem to have all the advantages I&#x27;ve described above.&lt;&#x2F;p&gt;
</description>
            </item>
        
            <item>
                <title>VxWorks</title>
                <pubDate>Sat, 15 Oct 2016 00:00:00 +0000</pubDate>
                <link>http%3A//itscomputersciencetime.com/public/vxworks-tricks/</link>
                <guid>http%3A//itscomputersciencetime.com/public/vxworks-tricks/</guid>
                <description>&lt;p&gt;I had never heard of VxWorks before coming to NASA, but now I have been using it for 
over 5 years. I thought I would write down some things I&#x27;ve learned- some tricks and
commands, concepts it uses, and larger scale considerations for programs written
for it.&lt;&#x2F;p&gt;
&lt;p&gt;In some ways, using VxWorks is simpler than, say, Linux. Once you spawn your tasks in
usrAppInit they just run- there is no file system assumed, very few other tasks, and very
few concepts to learn. A particular BSP (board support package) may have its own complexity,
but VxWorks itself is surprisingly simple. Code written for it will have only a couple 
of special types and a couple of libraries like msgQLib, semLib, taskLib, and for the
most part the operating system will just get out of your way. This
does have downsides when you wish certain features, primitives, programs, etc were
available. The situation seems to be getting better and better with new versions, but
you are sometimes at the mercy of your BSP.&lt;&#x2F;p&gt;
&lt;p&gt;Note that I&#x27;ve used VxWorks 6.7 for most of the development I&#x27;ve done, and only recently
started to use VxWorks 7.0. I haven&#x27;t used the new command line features much, the new
configuration system, or many of the new libraries. It seems much more complex, but
some of the libraries provide standard was to access hardware that are much better then
using system specific libraries for each project.&lt;&#x2F;p&gt;
&lt;p&gt;I also haven&#x27;t used the RTP features even in 6.7- we build a single kernel module which
runs in a single memory space.  This is simple, but less safe then the alternative.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h1 id=&quot;command-line&quot;&gt;Command Line&lt;&#x2F;h1&gt;
&lt;p&gt;First off, the VxWorks command line is indespensible. I have used VxWorks 6.7 for almost
the whole time I&#x27;ve been at NASA, and I haven&#x27;t gotten accustomed to the new VxWorks 7.0
extended command line, so these commands are for the default one that the system boots up
into in 6.7 and 7.0&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;i&lt;&#x2F;strong&gt; The information command &lt;strong&gt;i&lt;&#x2F;strong&gt; lists the current status of all VxWorks tasks.
I mostly use this for task status in case a task is suspended, making sure a task is present, 
getting the task id to use with another command, or for checking for errnos in tasks.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;ti&lt;&#x2F;strong&gt; The task information command takes either the task name or the task id number and prints
a detailed description of the task and its current status. I usually need this when a task
crashes and I want to look at the exception, the program counter, the stack pointer, and
the memory location that cause the crash for a memory access exception.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;tt&lt;&#x2F;strong&gt; The task trace command shows the current stack trace of a task. This is useful for
quickly finding the code that caused a trask to crash even without the debugger provided
by Workbench. Note that this command attempts to build a stack trace by inspection of the state
of the tasks stack- if there is memory corruption then it can be wrong.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;l&lt;&#x2F;strong&gt; The list command takes a memory location and produces a disassembly of the memory at that
location. It can also take a count of how many instructions to print.&lt;&#x2F;p&gt;
&lt;p&gt;If you don&#x27;t mind reading assembly, this can be a huge help. I&#x27;ve used it to understand stack
corruption problems, and to debug a very tricky problem that turned out to be caused by
loading a floating point number from a misaligned address on a PowerPC processor.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;d&lt;&#x2F;strong&gt; The dump command displays the contents of memory at a given location. It takes the
address to display from, the number of items to display, and the size of the items
(1, 2, 4, or 8).
This is one of my most used commands. If you need to inspect memory to understand how
a structure is layed out, find corruption, or inspect a stack then this command is the
fastest option. Against, you may be able to use the debugger, but more often I just
want to look around in memory, and this is the best way to do that.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;spy&lt;&#x2F;strong&gt; The spy command is a quick way to profile processor use. You provide it a period
and the number of samples per second, and it will print out a report at the end of the
period with processor usage information.&lt;&#x2F;p&gt;
&lt;p&gt;The profiling that it does is based on frequently sampling which task is running, and counting
how many times each task is observed to be running.&lt;&#x2F;p&gt;
&lt;p&gt;This is a command I&#x27;ve only recently discovered, and it immediately uncovered an issue with
log files on my current project. A single task was taking 30% to 40% of the total processor
time, which is a problem that could have gone unnoticed for a long time and only come up
monthes or years down the road.&lt;&#x2F;p&gt;
&lt;p&gt;Note that you can enable this command the kernel configuration if it is not available to you.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;lkup&lt;&#x2F;strong&gt; The lookup command is another one I use frequently. It takes a string argument and
searches for occurrances of that string in all defined symbols. This is a great way to
find function names that you can&#x27;t rememeber, or to inspect a system that you don&#x27;t have
code for to find useful information and functionality.&lt;&#x2F;p&gt;
&lt;p&gt;One other use is if your program&#x27;s symbols get any C++ name mangling.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;period&lt;&#x2F;strong&gt; The period command, gives you a way to spawn a process that you want to run 
on a period basis. You can use this to monitor or log information periodly and see how
things change over time.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;sp&lt;&#x2F;strong&gt; The spawn command lets you spawn any function as a task. One thing I use this for
is to run a long running function at a lower priority then the command line task. There are
two reasons to do this- one is that you can still use the command line while the other
task runs, and the other is that we always have watchdogs in our systems, and if the command
line task runs too long the task petting the watchdog can be starved, resetting the system.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;pre style=&quot;background-color:#212733;&quot;&gt;
&lt;span style=&quot;color:#ccc9c2;&quot;&gt;The defaults that *sp** provides are usually fine, but if you want you can specify
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ccc9c2;&quot;&gt;task priorities, stack sizes, etc with the taskSpawn command.
&lt;&#x2F;span&gt;&lt;&#x2F;pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The last thing I use the command line for is running my own functions. Any function that
is not declared static can be run from the command line.
This is a way to test functions and inspect the system at runtime. I write a lot of
utility functions, especially early on in a project, as well as units tests to run on
the command line.&lt;&#x2F;p&gt;
&lt;p&gt;Note that the command line doesn&#x27;t accept floats or doubles, so you have to be
a little tricker there.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h1 id=&quot;tasks&quot;&gt;Tasks&lt;&#x2F;h1&gt;
&lt;p&gt;Tasks are allocated a single block of memory that contains both their TCB (task control block)
and their stack. Note that in a kernel module all tasks run in the same flat memory space, allowing
them to corrupt each other&#x27;s memory.&lt;&#x2F;p&gt;
&lt;p&gt;Task priorities are ordered to that lower numbers mean higher priorities. Priorities greater then
10 are open for use by user code, with priorities lower than 10 reserved for VxWorks tasks.&lt;&#x2F;p&gt;
&lt;p&gt;If you need more control over task scheduling then priorities give you, such as maintaining
a global processing cycle with time slices allocated to different tasks, or a way to easily
schedule a task at a given rate, or just to monitor running tasks, consider writing a task
scheduler task. This task can use semaphores to release tasks, monitor that the tasks complete,
and could even keep statistics on tasks if you wanted. This sort of thing isn&#x27;t built into
VxWorks, but it makes a system much easier to reason about as compared to separate tasks all
scheduling themselves.&lt;&#x2F;p&gt;
&lt;p&gt;Since VxWorks is a real time operating system, the task with the highest priority that is ready
to run will have as much time as it needs. Lower priority tasks will be starved forever if
tasks do not release control by pending or delaying with taskDelay.&lt;&#x2F;p&gt;
&lt;p&gt;Task scheduling occurs after iterrupts, and in every system call. This is how a msgQSend or
semGive or any other call causes a rescheduling- a piece of VxWorks code is run to determine
if a new task with higher priority can now run.&lt;&#x2F;p&gt;
&lt;p&gt;If two tasks have the same priority then a round-robin scheduler is used. I&#x27;ve never used
this functionality, but it could be useful for tasks that can trade off control between
each other when they block.&lt;&#x2F;p&gt;
&lt;p&gt;One thing that always come up when talking about task priorities is (re)inversion of control.
If a low priority task task a resource, but is interrupted by a higher priority task, then it
will of course lose control. If the higher priority task then pends on the resource it will block
until the lower priority task releases it. This is called inversion of control because the lower
priority task now controls the higher priority one. The problem here is that the lower priority
task may not run if a medium priority task is ready, which blocks the high priority task, perhaps
indefinitely.&lt;&#x2F;p&gt;
&lt;p&gt;VxWorks deals with this by re-inversion of control- the task priority of a task that takes a
resource is the highest priority of any task pending on that resource.This means that a low
priority task with a resource will run until it gives up that resource to prevent it from blocking
out a higher priority task that is pending on the same resource.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;message-queues&quot;&gt;Message Queues&lt;&#x2F;h1&gt;
&lt;p&gt;The main communication we use between tasks are message queues. Message queues
in VxWorks are great, but they do have some limitations- you can&#x27;t empty a queue without just reading out
all of its messages, and they allocate space for the largest message you can receive. This means
that if you have a queue that needs to receive a lot of types of messages, and needs to be large,
you either waste a lot of space or you need a series of queues of different sizes.&lt;&#x2F;p&gt;
&lt;p&gt;This comes up when writing logging tasks that store data from the rest of the system. These
tasks usually have low priorities and huge queues- you don&#x27;t want to lose data, but logging can 
happen at any time.&lt;&#x2F;p&gt;
&lt;p&gt;If you split the messages into several queues just be aware that you can&#x27;t
simply pend on the first message from any queue- you have to poll, release a semphore when
queuing, use a counting semaphore, or have a &amp;quot;message description&amp;quot; queue. The last option is
where you have a separate queue where you queue an indicator of which of the other queues to
read from- if you receive a small message, you put it on the smallest queue and write
SMALL_MESSAGE_QUEUED (for exampled) to the message description queue. You can then pend on this
queue, and it will tell you which of the other queues to read from.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;interrupts&quot;&gt;Interrupts&lt;&#x2F;h1&gt;
&lt;p&gt;The main thing to know about interrupts in VxWorks is that you are allowed to release semaphores
and write to queues with NO_WAIT, but not to take semaphores or to receive messages.&lt;&#x2F;p&gt;
&lt;p&gt;If you need to print from an ISR (for debugging) you have to use logMsg from logLib- this will
log the message you want to print to a queue which is when printed when the log task runs.&lt;&#x2F;p&gt;
&lt;p&gt;Another thing to know about ISRs- when they perform system calls like message queue sends or
semaphore gives, the action they request is not actually performed. It is merely logged to a
global queue, and then run when the ISR exits. This prevents inconsistent views of the VxWorks
operating system state.&lt;&#x2F;p&gt;
&lt;p&gt;When an ISR exits, the system does not simply return to the last running task. There is a piece
of VxWorks operation system code that performs the ISR&#x27;s actions and reschedules tasks if
necessary.&lt;&#x2F;p&gt;
&lt;p&gt;Also note that ISR (interrupt service routines) run in a special interrupt stack (as far as I
know). I believe in older VxWorks versions they use the current task&#x27;s stack, but that was changed.&lt;&#x2F;p&gt;
&lt;p&gt;It goes without saying, but I will say it anyway- keep your ISRs short. This is true in any
system- interrupt latency is a global issue. Any time you spend in an interrupt will create
jitter in measurements and hold off other interrupts. Some ISRs have do a lot of work,
especially when trying to figure out who caused a hardware interrupt.
If you interact with the hardware in your own interrupts, just be aware that things like 
transactions with hardware, say across a PCI or cPCI bus, are expensive.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;watchdogs&quot;&gt;Watchdogs&lt;&#x2F;h1&gt;
&lt;p&gt;VxWorks provides a software watchdog mechanism. You register a function to run after a certain
number of system clock ticks, and VxWorks will call your function is its own system clock tick
interrupt. This means that precautions related to writing ISRs apply to watchdog functions.&lt;&#x2F;p&gt;
&lt;p&gt;I&#x27;ve used these for keeping track of system time, incrementing a counter when the watchdog goes
off, and for ensuring that certain events occur. The second use is more like what a hardware
watchdog would do- if you don&#x27;t keep rescheduling your software watchdog it goes off and
either resets the system, or reports a problem.&lt;&#x2F;p&gt;
&lt;p&gt;This is especially important in hard real time system where exceeding a time limit is a
catastropic problem and there needs to be a fail-safe executed if that occurs.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;ring-buffers&quot;&gt;Ring Buffers&lt;&#x2F;h1&gt;
&lt;p&gt;VxWorks does have ring buffers. Read rngLib documenation for details, but these ring buffers
do not perform locking and unlocking- they are intended to be used in a single reader, single
writer context between tasks without requiring synchronization. If you need mutual exclusion
because you have multiple readers or writers, you need to ensure that yourself with a mutex.&lt;&#x2F;p&gt;
&lt;p&gt;These ring buffers are byte based- you can read and write a whole buffer into the ring buffer
in one function call, but the buffer itself only knows about bytes. This means you either
have to have fixed size messages, a message header, or some other way to know how to decode
the data on the ring buffer.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;semaphores&quot;&gt;Semaphores&lt;&#x2F;h1&gt;
&lt;p&gt;VxWorks provides a couple of different semaphore types. Like with message queues, VxWorks doens&#x27;t
provide every nice feature, it just provides simple features with solid implementations.&lt;&#x2F;p&gt;
&lt;p&gt;The semaphores that it provides are binary semaphores (mostly for signalling), counting semaphores
(mostly for resource control), and mutexes (for mutual exclusion of a resource). There is
also a shared memory semaphore which I have never used, but is perhaps useful in shared memory
systems.&lt;&#x2F;p&gt;
&lt;p&gt;These concurrency primitives are common, so I won&#x27;t go into detail on them in this post.
There are certainly other primitives one might want (like MVars or concurrent ring buffers),
so just note that you might have to implement them yourselve using the primitives VxWorks provides.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;errno&quot;&gt;Errno&lt;&#x2F;h1&gt;
&lt;p&gt;VxWorks keeps a task-local errno for each task. You can access this with the variable errno, which
is just a macro that expands out to an access to the errno field of the current task&#x27;s TCB.&lt;&#x2F;p&gt;
&lt;p&gt;The way to use errno is to check the return of all system calls, and if it is not OK then to
look at the errno. You can clear the errno with errnoSet if you know a call will set the errno
and you don&#x27;t want it to be left set.&lt;&#x2F;p&gt;
&lt;p&gt;The main thing that triggers errnos for me is timeouts on semaphore or queues, and sometimes
invalid handles to queues or semaphores. Other conditions are definitely possible though.&lt;&#x2F;p&gt;
&lt;p&gt;The one time I actually cleared an errno was to detect when a task overran its allocated time.
It was important that the task not start itself in the middle of its time slice, but if it overran
its time limit and attempted to pend for its scheduling semaphore (released by another task)
then it would immediately see that the sempahore had been given and start in the middle of the
time slice.&lt;&#x2F;p&gt;
&lt;p&gt;What I ended up doing was attempting to take the semahpore with NO_WAIT as soon as the task
was complete, and if this succeeded then the task must have overran its time limit enough
that it had been scheduled again. In this case I would wait for the next time slice by
taking the semaphore (after reporting the problem of course). If the semaphore had not been given, 
then the task would just take the semaphore again with a longer wait time.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;time&quot;&gt;Time&lt;&#x2F;h1&gt;
&lt;p&gt;Time is a very complex topic, so I will just mention sysLib and timerLib. Note that your system
may has a primary and an auxiliary clock with different rates, and that you may need to set
the system clock rate with sysClkRateSet during initialization.&lt;&#x2F;p&gt;
&lt;p&gt;Scheduling wait times and delays usually use sysClkRateGet, and you can connect a callback
to the system clock with sysClkConnect.&lt;&#x2F;p&gt;
&lt;p&gt;Make sure you understand time in your system, and if timestamps are important make sure
you look at drift with respect to a trusted time source (like a pulse generator) so you
can correct for drift in software, hardware, and due to thermal effects on the oscillator
used for the system clock.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;The documentation I use the most when programming in VxWorks is &lt;a href=&quot;http:&#x2F;&#x2F;www.vxdev.com&#x2F;docs&#x2F;vx55man&#x2F;vxworks&#x2F;ref&#x2F;libIndex.htm&quot;&gt;here&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;VxWorks 7.0 is different in some ways from 6.7, and its worth looking over the documentation of the version
you are using to make sure you get the right information.&lt;&#x2F;p&gt;
&lt;p&gt;There is a lot more to say about using VxWorks, but I think this is all I can handle for now.&lt;&#x2F;p&gt;
</description>
            </item>
        
    </channel>
</rss>
