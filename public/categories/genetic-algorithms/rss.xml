<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>itscomputersciencetime</title>
        <link>http%3A//itscomputersciencetime.com/public</link>
        <description></description>
        <generator>Zola</generator>
        <language>en</language>
        <atom:link href="http%3A//itscomputersciencetime.com/public/categories/genetic-algorithms/rss.xml" rel="self" type="application/rss+xml"/>
        <lastBuildDate>Wed, 08 Aug 2018 00:00:00 +0000</lastBuildDate>
        
            <item>
                <title>Purely Functional Genetic Algorithms</title>
                <pubDate>Wed, 08 Aug 2018 00:00:00 +0000</pubDate>
                <link>http%3A//itscomputersciencetime.com/public/purely-functional-genetic-algorithms/</link>
                <guid>http%3A//itscomputersciencetime.com/public/purely-functional-genetic-algorithms/</guid>
                <description>&lt;p&gt;This post is about what a Genetic Algorithm would look like if seen through the lense of functional programming.
This means we will look at functional programming techniques and see if they have anything interesting to say about
Genetic Algorithms (and perhaps evolutionary algorithms in general). This post will focus on data structure choice more
then architecture or design, but I think there are interesting things to say about these types of topics as well.&lt;&#x2F;p&gt;
&lt;p&gt;You do see functional programming in Genetic Programming sometimes, but this post is specifically about
Genetic Algorithms.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;why-is-this-interesting&quot;&gt;Why is this Interesting?&lt;&#x2F;h1&gt;
&lt;p&gt;I believe that by making use of some unconventional thinking in the implementation of a Genetic Algorithm we can get some
performance improvements that you would not normally see. It seems like the GA literature generally considers
performance a secondary concern with these algorthms- the conventional wisdom is that fitness evaluation for your particular
problem is &lt;em&gt;so expensive&lt;&#x2F;em&gt; that the GA performance doesn&#x27;t make much or any impact. This is predicated on an unstated premise,
which is that the GA itself is independant of fitness evaluation, and can&#x27;t effect its performance.&lt;&#x2F;p&gt;
&lt;p&gt;I believe that this is not true, and that the use of a couple of fairly simple changes to a GA can actually speed up not just
evolution, but also your fitness evaluation. This is a pretty strange claim, and unfortunately I don&#x27;t have the benchmarks to
show for it. I have had this idea for a while, but I don&#x27;t have the time to put in the work to prove it, so I wanted to get
this concept out there in case I never have a chance to show it empirically.&lt;&#x2F;p&gt;
&lt;p&gt;To avoid keeping you waiting- it looks like you can reduce the algorithm complexity of a GA from its usual, imperative,
implementation while also using structural sharing to reduce the size of the population, which should result in better cache
use when performing fitness evalution. It may be that this does not have enough effect in practice to counter the branching
data structures we will use, which is why it needs to be evaluated in practice.&lt;&#x2F;p&gt;
&lt;p&gt;There is another aspect to this that I think is of independant interest, which is whether the functional programming community
has something to add to the machine learning discussion. There are other &lt;a href=&quot;http:&#x2F;&#x2F;colah.github.io&#x2F;posts&#x2F;2015-09-NN-Types-FP&quot;&gt;examples&lt;&#x2F;a&gt; of this ,
but I haven&#x27;t seen the equivalent for Genetic Algorithms. I think GAs are an interesting thing to point this FP light on because their
usual implementation is very dense and mutation heavy, which is very different from the tree structures and immutable structures we see
in some functional programming languages.&lt;&#x2F;p&gt;
&lt;p&gt;This post is not quite at the conceptual level as the neural network posts, but currently the only example of a GA paper from the FP community is
a simple implementation
&lt;a href=&quot;https:&#x2F;&#x2F;www.researchgate.net&#x2F;profile&#x2F;A_Garmendia-Doval&#x2F;publication&#x2F;2411892_A_genetic_algorithm_framework_using_Haskell&#x2F;links&#x2F;53d6c7840cf220632f3ddb04&#x2F;A-genetic-algorithm-framework-using-Haskell.pdf&quot;&gt;A genetic algorithm framework using Haskell&lt;&#x2F;a&gt;,
and a number of very good an interesting, but fairly traditional libraries.
I may be wrong about this, but this is what I have been able to find.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;lets-look-at-genetic-operations&quot;&gt;Lets Look at Genetic Operations&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;mutation&quot;&gt;Mutation&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;em&gt;Speeding Up Mutation&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Lets start with mutation. Nearly every GA library I&#x27;ve ever seen (and I&#x27;ve checked dozens) implements mutation as a loop which
checks whether to mutate each index of each individual. I&#x27;ve seen some libraries that technically cheat and just mutate a fixed
number of locations: 1 &#x2F; pm locations, where pm is the mutation rate.&lt;&#x2F;p&gt;
&lt;p&gt;I&#x27;ve found that this is a particularly slow operation- if you are evolving an individual of bits, you have to inspect every single
bit and generate a random number even though most bits will not be mutated. Instead, we could just sample from a geometric distribution
which tells us how many locations to skip before the next mutation. Sampling a geometric distribution tells you how many times a 
biased coin would land on tails before the first head. This means that a sample tells us how many times we would have passed over
a location before we mutated one without actually checking each one individually!&lt;&#x2F;p&gt;
&lt;p&gt;This technique is not actually specific to FP (although we will see some implications later to this choice), but I&#x27;ve never seen it
done in the wild.&lt;&#x2F;p&gt;
&lt;p&gt;Note that this idea works best for low mutation rates- as your mutation rate goes up this will actually become slower. For a mutation
rate of 0.01 (1% of locations mutated) we can skip an expected 100 locations per jump as the expected value of a geometric distribution
is just one over the probability of success. If our mutation rate is 0.001 then we will skip an expected 1000 locations! However, if our
probability is 0.5, we are doing a more complex computation to get our random value then we would from a bernoulli distribution. This is
a tradeoff, and perhaps the library could switch when it estimates that the payoff is no longer worth it to avoid this slowdown.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Mutation in a Purely Functional Language&lt;&#x2F;em&gt;
If we are going to make this purely functional, we certainly won&#x27;t be mutating data while doing a literal mutatation operation. We also
don&#x27;t want to do the naive method of copying all of our data and changing only the places we mutate- this would work, but it will put us
behind the imperative approach on our first operator!&lt;&#x2F;p&gt;
&lt;p&gt;Instead, lets use a data structure that allows us to traverse it quickly by splitting it, changing individual locations, and then concatenating
the results. As we will see later, a (finger tree)[http:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;containers] is a good choice for this kind of operation, taking
log time (its actually better then log time, but for simplicity I will refer to it as a log time operation).&lt;&#x2F;p&gt;
&lt;p&gt;To do this, we would sample from our geometric distribution, split our individual at the location we get (a log time operation), mutate the
head of the resulting list (a constant time operation), and continue.&lt;&#x2F;p&gt;
&lt;p&gt;Note that even this is not as fast as it would be if we directly modified data. We have turned the usually random access to the individual into
a log time operation to get to the data we want to change, and a log time operation to put it back together. Technically, the log is not of the 
individual size, but of the expected number of locations we skip to get to the next mutation, making it p*n*log(1&#x2F;pm), which is still a 
p*n complexity with a weird constant.
However, we will see later that this data structure choice will result in a lower algorithmic complexity for the GA overall, so bear with me.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Complexity&lt;&#x2F;em&gt;
For those of you keeping score, the complexity of mutation is usually the size of the population times the length of the individuals- p*n lets say.
The geometric distribution does not technically lower the complexity from being linear in the length of the individuals, but the constants should be
more like p*n*pm where we multiple the amount of work my the mutation rate. Due to our functional data structure&#x27;s log time features, we end up with
p*n**pm*log(n) as we have to do a log time operation as many as n*pm times.&lt;&#x2F;p&gt;
&lt;p&gt;Okay, so far we are slightly worst then the imperative implementation, but keep reading.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;crossover&quot;&gt;Crossover&lt;&#x2F;h2&gt;
&lt;p&gt;In a typical implementation of a GA, crossover involves copying or swapping data between individuals, resulting in an operation that is linear in the
length of the individuals, and linear in the number of individuals.&lt;&#x2F;p&gt;
&lt;p&gt;This is where our choice of finger tree starts to pay off- splitting and concatenating finger trees is only logorithmic! This leaves us with a complexity
that is p*log(n), which is better then the p*n we get in the imperative setting.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;selection&quot;&gt;Selection&lt;&#x2F;h2&gt;
&lt;p&gt;Selection is a population-level operator- the selection operators (examples being roulette wheel, stochastic universal sampling, tournament
selection, etc) don&#x27;t make use of the particular representation of individuals. So far we have not nailed down what structure to use for our
population itself.&lt;&#x2F;p&gt;
&lt;p&gt;Morally, a population is usually a multiset, except for a cellular genetic algorithm where you introduce some kind of topology.  However,
for simplicity and speed we can just use an (array&#x2F;vector type)[http:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;vector]. At first this seems like we are not
gaining anything on the imperative implementation, but in fact our choice of an immutable data structure has started to pay off. When we select
an individual more then once, we don&#x27;t have to copy them at all! Our vector simply points to the same individual multiple times, safe in the knowledge
that it won&#x27;t change. This moves us from an p*n operation (at worst the whole population has to be moved during selection) to an p time operator, depending
only on the size of the population. This does not take into account any processing we need to do for a particular selection algorithm which should not
change from the usual implementation.&lt;&#x2F;p&gt;
&lt;p&gt;While this reduction in complexity is great by itself, there is a more subtle effect here- after the first generation, some individuals will start
sharing the same data (structural sharing). Even after mutation and crossover, much of the data will continue to be shared. The amount of shared
data seems like it is related closely to the diversity of the population, so as the population converges and diversity falls, the amount of memory
that your population takes falls with it.&lt;&#x2F;p&gt;
&lt;p&gt;I would expect that this could have an effect on both the performance of the genetic algorithm, and of the fitness function. The fitness function is working on a
potentially much smaller data set then it would other be working on. There is a tradeoff however- the tree structures may be splayed out all over memory at this point
and we may actually lose all the gains we got from our smaller data set. There is some possibility of &amp;quot;compacting&amp;quot; the population at some point, organizing it
to avoid some of the problems here, but I don&#x27;t know right now how we would do this or if it would mitigate this problem.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h1&gt;
&lt;p&gt;The resulting algorithm should go from a p*n + p*n + p*n algorithm to p*n*log(1&#x2F;pm)*pm + p*log(n) + p time algorithm. The complexity class has not
changed, and mutation will be slower (by a log factor, which isn&#x27;t so bad) compared to the imperative algorithm (if it implements the geometric
distribution trick). However, crossover and selection seem like they should be much, much faster, and there is potentially gains in cache
usage as our population diversity decreases.&lt;&#x2F;p&gt;
&lt;p&gt;As mentioned, I would love to see some fair benchmarks that show whether this works in practice. I&#x27;m truely not sure whether data set size or predicatble organization
matters more on a modern processor.&lt;&#x2F;p&gt;
&lt;p&gt;Also as mentioned, this post did not mention the application of functional programming techniques to the concept of Genetic Algorithms, their architecture, or to the
implementation of their operations beyond data struture choice. I have thoughts on this as well, but the use of finger trees was the concept I wanted to get out their
first.&lt;&#x2F;p&gt;
&lt;p&gt;Thank you for reading!&lt;&#x2F;p&gt;
</description>
            </item>
        
    </channel>
</rss>
