<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Its Computer Science Time! - Flight Software Architecture</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">My Hakyll Blog</a>
            </div>
            <div id="navigation">
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../archive.html">Archive</a>
            </div>
        </div>

        <div id="content">
            <h1>Flight Software Architecture</h1>

            <div class="info">
    Posted on December 11, 2017
    
        by Noah Ryan
    
</div>

<p>I’ve found over the last 6 years that flight software is its own programming domain with its own techniques, concerns, tools, and mentality. I thought it would be good to go over some things I’ve learned and share my experiences with this kind of software and its design. Its a world in its own, and I’ve seen only a small slice of this world, but its still hard earned experience worth sharing.</p>
<p>This could go on for many postsafter post, so this one will just introduce some ideas.</p>
<h1 id="what-is-flight">What is “Flight”</h1>
<p>The distinction of “flight” software versus other software is that it either goes on an airplane or in space. This software is often high assurance- it is built to more rigorous standards, with a more intensive process, than other software. Note however that being “flight” does not by itself make it high assurance software- there are classes that indicate how critical the software is. Class A include software on vehicles with human beings, and critical functionality that humans depend on. Class B is for secondary systems, and for larger robotic systems. The other classes can be smaller missions, and systems that are not used for critical functions and have no ability to impact critical systems. These classes are also used for ground software, but thats not the subject of this post.</p>
<h1 id="cfs">CFS</h1>
<p>The best example that I can provide of flight software is <a href="https://github.com/nasa/cFE">CFS</a>. Its well used, well documented, and comes with a unit test suite for each module. The link is to CFE, the core set of modules for the CFS system, and there are other modules you can get <a href="https://github.com/nasa">here</a>. This system implements core functionality for flight software systems in a set of modules called CFE, and then provides a set of modules uses these core systems. The user then configures the core modules and any additional modules they need, and adds their own modules- either for generic functionality not provided by CFS or for mission-specific code like the control of a subsytem or a hardware interface to a spacecraft bus.</p>
<p>I have worked with other flight software, and only recently gotten into using CFS. I like CFS, even when I disagree with parts of its design, and I have been impressed with it in practice- I was able to get a fairly complete flight software system set up and start writing my mission code fairly quickly as a one-man team on one of my projects. I haven’t had to change almost anything within CFS itself- in the core CFE modules or the application modules- so in practice they truely are generic and truely are modular. It is not a perfect system, and I would like to work towards some improvements, but its very good, well tested and has heritage in other missions, which does weigh in its favor.</p>
<h1 id="flight-software-concepts">Flight Software Concepts</h1>
<p>There are a series of concepts that seem common in flight software systems. Each one can be handled in a variety of ways, but in general flight software tends to have many of the following systems: * Telemetry Collection * Command Handling/Routing * Fault Detection, Isolation, and Recovery (FDIR) * Software Messages / Event Messages * Hardware interfaces * Mode Control * Table Management (Configuration) * Command Sequences (relative time and absolute time) * File Transfer * Data Storage * Task Scheduling * Time Management</p>
<p>There are also some utilities that are common to see: * Fixed size allocation for packets and other structures * Time stamp generation * Packet creation/modification/inspection (usually CCSDS), and packet routing * Logging * Critical error reporting</p>
<p>We also need operating system functionality like: * Threads * Queues * Binary semaphores * Mutexes * Counting semaphores * Ring buffers</p>
<p>Other concepts may be used if available, or built if needed, but this is a basic list of functionality you will need in a flight software system. Some of this is overkill for smaller systems, but scales to larger ones.</p>
<p>Each of these deserves a post of its own. There are a lot of details here.</p>
<h1 id="flight-software-implementation">Flight Software Implementation</h1>
<p>The flight software I’ve seen is either in C/C++ or plain C. CFS/CFE is an example of plain C, and I would like to do a future post on why I think C is the right language to have choosen for this work.</p>
<p>The code is broken up into modules called either modules, apps (in CFS), or CSC (computer software components). Each module implements one task or chunk of functionality- each of the concepts listed above can have its own module. Modules boundaries are controlled- memory is usually not shared, and communication is mostly through message passing. Function calls also occur for some functions, like getting a timestamp or unblocking a task on a schedule.</p>
<p>A module may implement a hardware interface, a mission specific requirement like the managment of science data, or the management of a particular algorithm. They tend to have acronyms for their names, like TBL for table management, SC for stored command management, or SB for a software bus.</p>
<p>Each module is a sigificant amount of work requiring design and implementation, review, documention, and testing. The testing can be on a unit level, and a system level when possible.</p>
<h1 id="complex-algorithms">Complex Algorithms</h1>
<p>Its common that flight software contains algorithms that are developed by an expert in some field. This can be something like predicting the geometry of a system throughout its orbit, the sequence of actions for the system’s main task like collecting science data, or other algorithms. Each of these is a challenge in software- the algorithm is best understood by someone who is rarely a software engineer, and the implemention must be verified by a combination of software testing and algorithm testing. The boundary between what is the responsiblity of the software engineer and the domain expert can be difficult.</p>
<p>I’ve had good experience with algorithm designers that are willing to go through software processes, will provide test cases for me to run against my implementation, and will go over the implementation with me.</p>
<p>One lesson I’ve learned is to always set up your algorithm so it can be run off the flight system- it should be able to run on a laptop by anyone who needs to. This allows us to experiment with the algorithm, do debugging in case of problems, and allow people to do their own analysis without flight software support.</p>
<h1 id="software-updating">Software Updating</h1>
<p>The ability to update software in operation is vital. Its own of the reason to prefer doing things in software when possible- software is softer then firmware and hardware, as you might expect. This is a delicate process as a mistake here can render a system unbootable and end your mission. Test this as much as possible and always do it in the same way.</p>
<p>Its preferable to build your software into a single image when possible. This image can be stored in a persistant memory device like flash, and can be stored redundantly and with CRCs or other checks. My experience has been to prefer triple redundancy whenever possible, and to store a CRC32 with the data so you can check integrity without having to compare the images. One other detail is if you have no valid images, nominate one to boot anyway- its a last ditch effort but if all your images are corrupt its worth trying to boot so you can fix the problem with a running system just hope your corruption is in an non-vital area.</p>
<p>There will usually also be more then one version of the software on a system. My experience is that it is much better to keep a golden image that is never updated and a main image that is used for operations then to allow multiple images that can each be updated. Keep this simple and avoid the possibility of confusion- when confusion is possible it will occur.</p>
<h1 id="flight-software-mentaliity">Flight Software Mentaliity</h1>
<p>There is a lot to say here, but I just want to say that I’ve learned to prefer flight software that is simple, uses as few concepts and syntax as possible, is as consistant in any way possible (variable and function names, checking, messaging, testing, debugging, comment- every you can), does not have too much extra functionality that can lead to errors while having nicities that your operators will thank you for, checks all possible error conditions, provides insight into its operation and is loud about all errors, contains as little state as possible, and as a rule is simple above almost anything else. It must be reviewable both by your coworkers, and by you in a year when you have forgotten how it works.</p>
<p>Flight software is much, much more risk adverse then other software. This shows up in all places, and can lead to designs that would be hard to understand in other software. We have a great deal of flexibility in software with how to do things, but in flight software we have to be more restricted and careful with our designs. It is better to limit how the system works whenever possible so that only correct behavior is possible. We have to be very pessimistic: expect errors, expect hardware failures, expect software failures (even in our own software), expect anything you can think of.</p>
<h1 id="flight-softwares-role">Flight Software’s Role</h1>
<p>Again, there is too much to say, but I will try. The software discipline needs to get people thinking about their conops and how they want to operate a system. We need to let them know what software can do and what the options are taking into account cost, complexity, and the effect of each feature on the software as a whole. We need to keep people up to date on progress and implemention- people have a hard time understanding software, and we need to communicate what we are doing and why. We need to be transparent- our software repositories are a resource to the project and not just our own. Our documentation is important for operators. Our design decisions effect people just like the decisions of any other disicpline, and we need to communicate those decisions and why we made them to the project, documenting our reasoning for the day that our implementation effects other peoples jobs.</p>
<p>Software needs to be part of a project early on to get its needs and requirement in the mix, and to inform people about the cost and ability of software systems. People over and under estimate software in many areas and need a software domain expert to answer these questions. On the other hard, software often has little work early on, in the mission concept planning. In that stage I think we can provide engineering insight and just help when possible, knowing that the actual role software itself is a long way off.</p>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
