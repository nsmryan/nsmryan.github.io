<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Its Computer Science Time! - Cello</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">My Hakyll Blog</a>
            </div>
            <div id="navigation">
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../archive.html">Archive</a>
            </div>
        </div>

        <div id="content">
            <h1>Cello</h1>

            <div class="info">
    Posted on March  9, 2018
    
        by Noah Ryan
    
</div>

<p>I’ve been thinking about C programming a lot lately, and what its limits are. This lead my to a very interesting C library call <a href="http://libcello.org/">cello</a>. I highly recommend reading this page, and looking through the source code. The author deserves some notice for such an interesting library.</p>
<p>Cello is described as a library that brings high level programming to C. This includes quite a lot of functionality such as generic data structures with mapping and folding, polymorphic functions, threading and synchronization, garbage collection, a type class / interface mechanism, and higher order functions. Its surprising how much leverage you can get from this- you can extend this library with new interfaces, functions, and structures, and get a good bit of functional programming into C as well as build high level interfaces. You can fit interator, streams, references, and all sorts of other things that are usually much more manual in C- its quite impressive to see an encoding of these concepts in C that is not an intrusive set of complex macros!</p>
<p>The way all of this is implemented seems to be with <a href="http://libcello.org/learn/a-fat-pointer-library">fat pointers</a>, where a pointer points to data as usual, but there is extra metadata just before the pointer in memory. This technique is also used in the Forth community, where you can jump right to the code for a word, but can also back up and find things like the words name as a string and flags for its execution.</p>
<p>This mechanism allows pointers (all of these seem to be of type void&amp;ask;) to have a structure of properties. It appears (through some quick check in the source code) that Cello looks up properties in some kind of table in order to dispatch the correct implementation for a function. This is more flexible than a v-table style, where these must be known statically for each class, but does incure some run-time overhead. Interestingly this makes it a bit more typeclassy in the Haskell sense (ignoring the dynamic types for now) because you have a single implemenation of an interface per type.</p>
<p>Unfortunately, while this is very interesting, I would not be able to use it for my work, and I would likely move to another language rather then accept a non-standard style in C. I’m used to a very restricted C style for high assurance systems, and this is too much of a pervasive change to how you use to language for me to invest time in using it. Howver, it is a certain point in the generic C design landscape with a novel set of tradeoffs compared to what I’ve seen done in C.</p>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
