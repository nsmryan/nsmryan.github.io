---
title: Why I use C
author: Noah Ryan
---
This post is about why I use C for my work, and why I chose to use C in 2018. I am hoping to cover where this choice comes from
and what advantages and disadvantages it has, specifically for the sort of work that I do.


The reasons are not for performance or code size, and not necessarily even for safety. Its more consistency, explicit expression,
reviewability, and maintanebility. Its about support, tooling, ecosystem, practice, and process.


Language choice is a very important- you inherit your ecosystem, tools, and the mentality and capabilities of your
language as your framework for expressing yourself, and its important to think carefully about language when starting a project.


The particular domain I will talk about is embedded systems work for the flight software systems I have worked on at
NASA. These are not the resource contrained systems that some embedded software inhabits- I haven't done microcontrollers for this work,
I've only done processor boards with hundreds of megabytes of RAM and flash, and processors in the hundreds of megahertz
range. They are fairly powerful for what they are- you need to be aware of resources, and careful about timing and latency, 
but they don't have the scarcity of resources that some systems have.


I see places in this post where my thinking may be formed by my choice of tools, where my estimate of costs and benefits are from the
perspective of the tools and practices that I have already chosen to use. This is not ideal, but requires some attention to notice, so
I will try to point it out when I see it in myself.


The Options
===
The main options for flight software systems are C and C++. There are examples of other language like Rust or Python being
used, or assembly for some things. However, I've never seen any language but C and C++ in high assurance system, so these
are the ones I will talk the most about. Certainly Ada is used in these domains, but I've never come across one of these systems.
I will try to outline why other languages do not work in this domain, although
I would like to be convinced otherwise one day.


If I could express at least some of my code in a safer language, use more modern
programming concepts, and have more algorithms and structures available, I would be more productive. There are 
many places where its easy to get bitten by the C/C++ scalpel, or to find that we can't be sure of correctness of
a section of code without a great deal of work. We handle this with stringent practices, review, unit testing, and system
testing, but I would prefer to not have to worry about some of the problems that lurk in most C/C++ code.

Something like [ivory](https://ivorylang.org/ivory-introduction.html), Rust, or one of the other safer but still low level
languages might be doable one day, and I would love to incorporate it into a smaller project and see if it helps.


However, we have to be pessimistic in our evaluation and only use languages and code
that we trust in this domain. No research or untested code can be used in the large projects- we have to make the best
decision as engineers who are following a process. We can't afford costly bugs or code that we don't understand fully,
and we already have so much infrastructure and so many practices built around the
C/C++ paradigm that its very hard to make any other choice. We have to estimate cost and schedule, and use operating systems,
drivers, and board support packages written in C/C++.


Consistency
===
In flight software, simplicity is vital. I use C because it is a relatively small language, and even so we use a subset of the language.
This means I use as few syntactic forms as possible, and enforce consistency in as many aspects of the code as possible.


This is a case where additional power is often not helpful- its a principal of least power sort of situation. Most of the problems we
solve are fairly straightforward- they do not usually require complex algorithms or data structures. For these situations, the cost
of abstraction is very apparent.

An example from my experience is a module for communicating with the MIL STD 1553B interface on the SAGE 3 project, which I wrote early in my career. 
I was used to abstraction and wrapping up functionality, so I wrote the code as an interface to the card driver. I found over the next years that
this was a mistake- the extra abstraction was never used, and didn't really help the original use that much. The interface is too complex and has very little
symmetry, so it needs to be understood in great detail and can't hide much complexity.


If I wrote this code today, I would have done it much more directly and procedurally. The mapping from the interface definition to the hardware would have
been very direct to assist review and maintenance. This would be done so that we could check how each transfer occurs and review that they are set up correctly,
without having to go through a layer of abstraction to deduce how things are configured.



Consistency is a place where I see a real danger in C++. When I have used C++ I have restricted myself to a very small subset of the
language, not using templates, inheritance, operator overloading, lambdas- in fact we use it as an expanded C. The advantages you get
are not bad- function overloading, default parameters, and access to a larger standard library do help. The cost that I see in this
is that consistency becomes a much more difficult battle to fight. It becomes a battle to keep things simple and choose which concepts to
introduce, and it can become very easy to make mistakes. This is not just an opinion- I found a case within a complex algorithm where
data was allocated at runtime, which is forbidden in our systems. It was not obvious that this was happening- the language left us open
to an implicit allocation that we were not used to seeing or reviewing for.


Complex Algorithms
===
Most systems will have a small number of complex algorithms, which is definitely a place where C is not the best fit. The lack of
abstraction and built-in tools can make this code more complex then necessary, and it is a place where translating from another language
does make sense. This is done in some systems- I've heard of Simulink used this way- but even with this strategy you face issues with
trusing the algorithm code. You have to make some decisions on how to review it, test it, and ensure maintain it  as part of the rest of the system.


C++ certainly has a lot of power, and I could see it being a step in the right direction in some cases. My main relunctance for these algorithms
would be wanting to avoid introducing too many new concepts- each new concept and its interaction with other concepts in the code adds complexity
and overhead into a largely manual review and testing process. I could see some of this being aleviated by better tooling that could replace
manual components, but I still think adheritance to simplicity is an important thing to hold on to.



Type Safety
===
C is not a type safe language. There are certain things it will catch, but in many cases the correct use of types is up to the programmer.
It is not dynamic, but we can cast pointers freely, and the language does not help us avoid
issues with memory use. We can cast incorrectly, index off of arrays, and overwrite memory almost anywhere.


One argument for C++ would be the ability to express more in its type system, and the ability to more clearly express and check casts.
I'm not well versed in this style, so it is hard for me to evaluate how this relates to my work. There may be an intermediate where some
safety can be gained with very little complexity that would improve overall code quality.


Tooling
===
Part of tooling for me is LabWindows, VxWorks, and CFE/CFS. It happens that I am in an environment that makes a great deal of use of C, so
naturally it is more confortable to keep it that way.


Some advantages here include being able to port code between an embedded system and a LabWindows tool, and making it easier to support compiling
an subset of the embedded code on a desktop. Certainly this can be done in C++, but I've always found it simplier to do with C then C++.


Another part of tooling is that the C language is simplier then C++, and easier to integrate with FFIs such as Lua, and just simplier overall.
This comes up rarely, but its an example of the downstream costs of complexity that effect every tool and concept involved in your code.

